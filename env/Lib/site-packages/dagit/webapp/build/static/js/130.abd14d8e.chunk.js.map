{"version":3,"file":"static/js/130.abd14d8e.chunk.js","mappings":"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","sources":["../../core/src/app/titleOfIO.ts","../../core/src/graph/layout.ts","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"],"sourcesContent":["export const DEFAULT_RESULT_NAME = 'result';\n\nexport const titleOfIO = (i: {solid: {name: string}; definition: {name: string}}) => {\n  return i.solid.name !== DEFAULT_RESULT_NAME\n    ? `${i.solid.name}:${i.definition.name}`\n    : i.solid.name;\n};\n","import * as dagre from 'dagre';\n\nimport {titleOfIO} from '../app/titleOfIO';\n\nimport {IBounds, IPoint} from './common';\n\nexport type OpLayoutEdgeSide = {\n  point: IPoint;\n  opName: string;\n  edgeName: string;\n};\n\nexport type OpLayoutEdge = {\n  from: OpLayoutEdgeSide;\n  to: OpLayoutEdgeSide;\n};\n\nexport interface OpLayout {\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n\n  // Frames of specific components - These need to be computed during layout\n  // (rather than at render time) to position edges into inputs/outputs.\n  op: IBounds;\n  inputs: {[inputName: string]: OpLayoutIO};\n  outputs: {[outputName: string]: OpLayoutIO};\n}\n\nexport interface OpLayoutIO {\n  layout: IBounds;\n  label: boolean;\n  collapsed: string[];\n  port: IPoint;\n}\n\nexport type OpGraphLayout = {\n  width: number;\n  height: number;\n  parent: ParentOpLayout | null;\n  edges: OpLayoutEdge[];\n  nodes: {[opName: string]: OpLayout};\n};\n\ninterface ParentOpLayout extends Omit<OpLayout, 'op'> {\n  mappingLeftEdge: number;\n  mappingLeftSpacing: number;\n  dependsOn: {[opName: string]: IPoint};\n  dependedBy: {[opName: string]: IPoint};\n  invocationBoundingBox: IBounds;\n}\n\nexport interface ILayoutOp {\n  name: string;\n  inputs: {\n    definition: {\n      name: string;\n    };\n    dependsOn: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n  definition: {\n    description: string | null;\n    assetNodes: {\n      assetKey: {\n        path: string[];\n      };\n    }[];\n  };\n  outputs: {\n    definition: {\n      name: string;\n    };\n    dependedBy: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n}\n\nconst OP_WIDTH = 370;\nconst OP_BASE_HEIGHT = 52;\nconst OP_ASSETS_ROW_HEIGHT = 22;\nconst IO_HEIGHT = 26;\nconst IO_INSET = 0;\nconst IO_MINI_WIDTH = 35;\nconst IO_THRESHOLD_FOR_MINI = 4;\nconst PORT_INSET_X = 13;\nconst PORT_INSET_Y = IO_HEIGHT / 2;\nconst PARENT_DEFINITION_PADDING = 70;\nconst PARENT_INVOCATION_PADDING = 70;\nconst EXTERNAL_DEPENDENCY_PADDING = 50;\n\nconst MARGIN_BASE = 100;\n\ntype OpLinkInfo = {\n  solid: {name: string};\n  definition: {name: string};\n};\n\nfunction flattenIO(arrays: OpLinkInfo[][]) {\n  const map: {[key: string]: OpLinkInfo} = {};\n  arrays.forEach((array) => array.forEach((item) => (map[titleOfIO(item)] = item)));\n  return Object.values(map);\n}\n\nexport function layoutOpGraph(pipelineOps: ILayoutOp[], parentOp?: ILayoutOp): OpGraphLayout {\n  const g = new dagre.graphlib.Graph();\n\n  // First, identify how much space we need to pad the DAG by in order to show the\n  // parent op AROUND it. We pass this padding in to dagre, and then we have enough\n  // room to add our parent layout around the result.\n  let parentIOPadding = 0;\n  let marginy = MARGIN_BASE;\n  let marginx = MARGIN_BASE;\n  if (parentOp) {\n    parentIOPadding = Math.max(parentOp.inputs.length, parentOp.outputs.length) * IO_HEIGHT;\n    marginx = PARENT_DEFINITION_PADDING + PARENT_INVOCATION_PADDING;\n    marginy = marginx + parentIOPadding;\n  }\n\n  // Define a new top-down, left to right graph layout\n  g.setGraph({rankdir: 'TB', marginx, marginy});\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const edges: OpLayoutEdge[] = [];\n  const opNamesPresent: {[name: string]: boolean} = {};\n\n  pipelineOps.forEach((op) => {\n    opNamesPresent[op.name] = true;\n  });\n  pipelineOps.forEach((op) => {\n    // Lay out each op individually to get it's width and height based on it's\n    // inputs and outputs, and then attach it to the graph. Dagre will give us it's\n    // x,y position.\n    const layout = layoutOp(op, {x: 0, y: 0});\n    g.setNode(op.name, {\n      width: layout.bounds.width,\n      height: layout.bounds.height,\n    });\n\n    // Give Dagre the dependency edges and build a flat set of them so we\n    // can reference them in a single pass later\n    op.inputs.forEach((input) => {\n      input.dependsOn.forEach((dep) => {\n        if (opNamesPresent[dep.solid.name] && opNamesPresent[op.name]) {\n          g.setEdge({v: dep.solid.name, w: op.name}, {weight: 1});\n\n          edges.push({\n            from: {\n              point: {x: 0, y: 0},\n              opName: dep.solid.name,\n              edgeName: dep.definition.name,\n            },\n            to: {\n              point: {x: 0, y: 0},\n              opName: op.name,\n              edgeName: input.definition.name,\n            },\n          });\n        }\n      });\n    });\n  });\n\n  dagre.layout(g);\n\n  const ops: {[opName: string]: OpLayout} = {};\n  const dagreNodes: {[opName: string]: dagre.Node} = {};\n  g.nodes().forEach(function (opName) {\n    const node = g.node(opName);\n    if (!node) {\n      return;\n    }\n    dagreNodes[opName] = node;\n  });\n\n  // Due to a bug in Dagre when run without an \"align\" value, we need to calculate\n  // the total width of the graph coordinate space ourselves. We need the height\n  // because we've shifted long single rows into multiple rows.\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  // Read the Dagre layout and map \"nodes\" back to our solids, but with\n  // X,Y coordinates this time.\n  Object.keys(dagreNodes).forEach((opName) => {\n    const node = dagreNodes[opName];\n    const op = pipelineOps.find(({name}) => name === opName);\n    if (!op) {\n      return;\n    }\n\n    const x = node.x - node.width / 2; // Dagre's x/y is the center, we want top left\n    const y = node.y - node.height / 2;\n    ops[opName] = layoutOp(op, {x, y});\n    maxWidth = Math.max(maxWidth, x + node.width);\n    maxHeight = Math.max(maxHeight, y + node.height);\n  });\n\n  // Read the Dagre layout and map \"edges\" back to our data model. We don't\n  // currently use the \"closest points on the node\" Dagre suggests (but we could).\n  g.edges().forEach(function (e) {\n    const conn = edges.find((c) => c.from.opName === e.v && c.to.opName === e.w);\n    const points = g.edge(e).points;\n    if (conn) {\n      conn.from.point = points[0];\n      conn.to.point = points[points.length - 1];\n    }\n  });\n\n  const result: OpGraphLayout = {\n    edges,\n    nodes: ops,\n    width: maxWidth + marginx,\n    height: maxHeight + marginy,\n    parent: null,\n  };\n\n  if (parentOp) {\n    // Now that we've computed the pipeline layout fully, lay out the\n    // composite op around the completed DAG.\n    result.parent = layoutParentGraphOp(result, parentOp, parentIOPadding);\n  }\n\n  return result;\n}\n\nfunction layoutParentGraphOp(layout: OpGraphLayout, op: ILayoutOp, parentIOPadding: number) {\n  const result: ParentOpLayout = {\n    invocationBoundingBox: {\n      x: 1,\n      y: 1,\n      width: layout.width - 1,\n      height: layout.height - 1,\n    },\n    bounds: {\n      x: PARENT_INVOCATION_PADDING,\n      y: PARENT_INVOCATION_PADDING + parentIOPadding,\n      width: layout.width - PARENT_INVOCATION_PADDING * 2,\n      height: layout.height - (PARENT_INVOCATION_PADDING + parentIOPadding) * 2,\n    },\n    mappingLeftEdge: PARENT_INVOCATION_PADDING - 20,\n    mappingLeftSpacing: 10,\n    inputs: {},\n    outputs: {},\n    dependsOn: layoutExternalConnections(\n      flattenIO(op.inputs.map((d) => d.dependsOn)),\n      -EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n    dependedBy: layoutExternalConnections(\n      flattenIO(op.outputs.map((d) => d.dependedBy)),\n      layout.height + EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n  };\n\n  const boundingBottom = result.bounds.y + result.bounds.height;\n\n  op.inputs.forEach((input, idx) => {\n    result.inputs[input.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      collapsed: [],\n      label: true,\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  op.outputs.forEach((output, idx) => {\n    result.outputs[output.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: boundingBottom + idx * IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      collapsed: [],\n      label: true,\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: boundingBottom + idx * IO_HEIGHT + IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  return result;\n}\n\nfunction layoutExternalConnections(links: OpLinkInfo[], y: number, layoutWidth: number) {\n  // fill evenly from 0 to layoutWidth from left to right, then center them if there's overflow.\n  const inset = PARENT_INVOCATION_PADDING + PORT_INSET_X;\n  const insetWidth = layoutWidth - inset * 2;\n  const spacing = Math.max(200, insetWidth / links.length);\n  const baseX = inset + Math.min(0, (insetWidth - links.length * spacing) / 2);\n  const yShift = spacing < 300 ? 20 : 0;\n\n  const result: {[opName: string]: IPoint} = {};\n  links.forEach((link, idx) => {\n    const shiftDirection = 1 - (idx % 2) * 2; // 1 or -1, alternating\n    result[titleOfIO(link)] = {\n      x: baseX + idx * spacing,\n      y: y + yShift * shiftDirection,\n    };\n  });\n  return result;\n}\n\nexport function layoutOp(op: ILayoutOp, root: IPoint): OpLayout {\n  // Starting at the root (top left) X,Y, return the layout information for an op with\n  // input blocks, then the main block, then output blocks (arranged vertically).\n  //\n  // This code \"appends\" boxes vertically, advancing accY as it goes.\n  let accY = root.y;\n\n  const appendMiniIODots = <T extends ILayoutOp['inputs'][0] | ILayoutOp['outputs'][0]>(\n    ios: T[],\n    sortKey: (io: T) => string,\n    clusteringKey: (io: T) => string,\n  ) => {\n    // Sort both input and output boxes displayed on the graph alphabetically based on the input name.\n    // This means that if two ops are connected to each other multiple times, the lines do not cross.\n    const sorted = [...ios].sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n\n    let x = 0;\n    let last: OpLayoutIO;\n    let lastKey: string | null = null;\n    const layouts: {[name: string]: OpLayoutIO} = {};\n    const spacing = Math.min(IO_MINI_WIDTH, OP_WIDTH / (sorted.length + 1));\n\n    // Add \"port\" layouts, collapsing the dots if they are connected to the same opposing solid\n    // (eg: two inputs connected to the same upstream output) with a \"[O] + 2\" style.\n    sorted.forEach((io, _idx) => {\n      const key = clusteringKey(io);\n      if (key !== lastKey) {\n        lastKey = key;\n        last = {\n          port: {\n            x: root.x + x + PORT_INSET_X,\n            y: accY + PORT_INSET_Y,\n          },\n          collapsed: [],\n          label: false,\n          layout: {\n            x: root.x + x,\n            y: accY,\n            width: IO_MINI_WIDTH,\n            height: IO_HEIGHT,\n          },\n        };\n        layouts[io.definition.name] = last;\n        x += spacing;\n      } else {\n        if (last.collapsed.length === 0) {\n          x += 15;\n        }\n        last.collapsed.push(io.definition.name);\n      }\n    });\n\n    // Center the items on the op rather than left justifying them\n    const centeringAdjustment = (OP_WIDTH - (x - PORT_INSET_X + IO_MINI_WIDTH)) / 2;\n    Object.values(layouts).forEach((l) => {\n      l.layout.x += centeringAdjustment;\n      l.port.x += centeringAdjustment;\n    });\n\n    // Place the next box beneath the\n    accY += IO_HEIGHT;\n\n    return layouts;\n  };\n\n  const appendStackedIOBoxes = (ios: ILayoutOp['inputs'] | ILayoutOp['outputs']) => {\n    const layouts: {[name: string]: OpLayoutIO} = {};\n    ios.forEach((io) => {\n      layouts[io.definition.name] = {\n        port: {x: root.x + PORT_INSET_X, y: accY + PORT_INSET_Y},\n        label: true,\n        collapsed: [],\n        layout: {\n          x: root.x,\n          y: accY,\n          width: 0,\n          height: IO_HEIGHT,\n        },\n      };\n      accY += IO_HEIGHT;\n    });\n    return layouts;\n  };\n\n  const inputLayouts =\n    op.inputs.length > IO_THRESHOLD_FOR_MINI\n      ? appendMiniIODots(\n          op.inputs,\n          (input) => input.definition.name,\n          (input) => input.dependsOn[0]?.solid.name || '',\n        )\n      : appendStackedIOBoxes(op.inputs);\n\n  const opLayout: IBounds = {\n    x: root.x,\n    y: Math.max(root.y, accY - IO_INSET),\n    width: OP_WIDTH,\n    height: OP_BASE_HEIGHT + IO_INSET * 2,\n  };\n\n  accY += OP_BASE_HEIGHT;\n\n  if (op.definition.assetNodes.length && op.definition.description) {\n    opLayout.height += OP_ASSETS_ROW_HEIGHT;\n    accY += OP_ASSETS_ROW_HEIGHT;\n  }\n\n  const outputLayouts =\n    op.outputs.length > IO_THRESHOLD_FOR_MINI\n      ? appendMiniIODots(\n          op.outputs,\n          (o) => o.dependedBy[0]?.definition.name || '',\n          (o) => o.dependedBy[0]?.solid.name || '',\n        )\n      : appendStackedIOBoxes(op.outputs);\n\n  return {\n    bounds: {\n      x: root.x - 5,\n      y: root.y - 5,\n      width: OP_WIDTH + 10,\n      height: accY - root.y + 10,\n    },\n    op: opLayout,\n    inputs: inputLayouts,\n    outputs: outputLayouts,\n  };\n}\n","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}"],"names":["titleOfIO","i","solid","name","definition","OP_WIDTH","IO_HEIGHT","PORT_INSET_X","PARENT_INVOCATION_PADDING","flattenIO","arrays","map","forEach","array","item","Object","values","layoutOpGraph","pipelineOps","parentOp","g","dagre","parentIOPadding","marginy","marginx","PARENT_DEFINITION_PADDING","Math","max","inputs","length","outputs","setGraph","rankdir","setDefaultEdgeLabel","edges","opNamesPresent","op","layout","layoutOp","x","y","setNode","width","bounds","height","input","dependsOn","dep","setEdge","v","w","weight","push","from","point","opName","edgeName","to","ops","dagreNodes","nodes","node","maxWidth","maxHeight","keys","find","e","conn","c","points","edge","result","parent","invocationBoundingBox","mappingLeftEdge","mappingLeftSpacing","layoutExternalConnections","d","dependedBy","boundingBottom","idx","collapsed","label","port","output","layoutParentGraphOp","links","layoutWidth","insetWidth","inset","spacing","baseX","min","yShift","link","shiftDirection","root","accY","appendMiniIODots","ios","sortKey","clusteringKey","last","sorted","sort","a","b","localeCompare","lastKey","layouts","io","_idx","key","centeringAdjustment","l","appendStackedIOBoxes","inputLayouts","opLayout","OP_BASE_HEIGHT","assetNodes","description","outputLayouts","o","_iterableToArray","iter","Symbol","iterator","Array","_toConsumableArray","arr","isArray","arrayLikeToArray","iterableToArray","unsupportedIterableToArray","TypeError"],"sourceRoot":""}