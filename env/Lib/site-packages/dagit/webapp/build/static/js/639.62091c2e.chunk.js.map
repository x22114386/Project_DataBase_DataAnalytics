{"version":3,"file":"static/js/639.62091c2e.chunk.js","mappings":"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","sources":["../../core/src/hooks/useDocumentTitle.tsx","../../ui/src/components/CodeMirror.tsx","../../ui/src/components/PageHeader.tsx","../../ui/src/components/Tabs.tsx","../../ui/src/components/configeditor/codemirror-yaml/mode.tsx"],"sourcesContent":["import * as React from 'react';\n\nexport const useDocumentTitle = (title: string) => {\n  React.useEffect(() => {\n    const currentTitle = document.title;\n    document.title = title;\n    return () => {\n      document.title = currentTitle;\n    };\n  }, [title]);\n};\n","import 'codemirror/lib/codemirror.css';\n\nimport * as React from 'react';\nimport {Controlled, UnControlled as Uncontrolled} from 'react-codemirror2';\nimport {createGlobalStyle} from 'styled-components/macro';\n\nimport {Colors} from './Colors';\nimport {Icons} from './Icon';\nimport {registerYaml} from './configeditor/codemirror-yaml/mode';\nimport {FontFamily} from './styles';\n\n// Explicitly register YAML to ensure that the YAML import is bundled correctly.\nregisterYaml();\n\nexport const DagitCodeMirrorStyle = createGlobalStyle`\n  .react-codemirror2 .CodeMirror {\n    font-family: ${FontFamily.monospace};\n    font-size: 16px;\n\n    /* Note: Theme overrides */\n    &.cm-s-default .cm-comment {\n      color: #999;\n    }\n  }\n\n  .CodeMirror-gutter-elt {\n    .CodeMirror-lint-marker-error {\n      background-image: none;\n      background: ${Colors.Red500};\n      mask-image: url(${Icons.error});\n      mask-size: cover;\n      margin-bottom: 2px;\n    }\n  }\n\n  .CodeMirror-hint,\n  .CodeMirror-lint-marker-error,\n  .CodeMirror-lint-marker-warning,\n  .CodeMirror-lint-message-error,\n  .CodeMirror-lint-message-warning {\n    font-family: ${FontFamily.monospace};\n    font-size: 16px;\n  }\n\n  .react-codemirror2 .CodeMirror.cm-s-dagit {\n    .cm-atom {\n      color: ${Colors.Blue700};\n    }\n\n    .cm-comment {\n      color: ${Colors.Gray400};\n    }\n\n    .cm-meta {\n      color: ${Colors.Gray700};\n    }\n\n    .cm-number {\n      color: ${Colors.Red700};\n    }\n\n    .cm-string {\n      color: ${Colors.Green700};\n    }\n\n    .cm-string-2 {\n      color: ${Colors.Olive700};\n    }\n\n    .cm-variable-2 {\n      color: ${Colors.Blue500};\n    }\n\n    .cm-keyword {\n      color: ${Colors.Yellow700};\n    }\n\n    .CodeMirror-selected {\n      background-color: ${Colors.Blue50};\n    }\n\n    .CodeMirror-gutters {\n      background-color: ${Colors.Gray50};\n    }\n\n    .cm-indent {\n      display: inline-block;\n\n      &.cm-zero {\n        box-shadow: -1px 0 0 ${Colors.Green200};\n      }\n\n      &.cm-one {\n        box-shadow: -1px 0 0 ${Colors.Blue100};\n      }\n\n      &.cm-two {\n        box-shadow: -1px 0 0 ${Colors.LightPurple};\n      }\n\n      &.cm-three {\n        box-shadow: -1px 0 0 ${Colors.Red200};\n      }\n\n      &.cm-four {\n        box-shadow: -1px 0 0 ${Colors.Yellow200};\n      }\n\n      &.cm-five {\n        box-shadow: -1px 0 0 ${Colors.Olive200};\n      }\n\n      &.cm-six {\n        box-shadow: -1px 0 0 ${Colors.Gray300};\n      }\n    }\n  }\n\n  div.CodeMirror-lint-tooltip {\n    background: rgba(255, 247, 231, 1);\n    border: 1px solid ${Colors.Gray200};\n  }\n\n  .CodeMirror-lint-message {\n    background: transparent;\n  }\n  .CodeMirror-lint-message.CodeMirror-lint-message-error {\n    background: transparent;\n  }\n\n  /* Ensure that hints aren't vertically cutoff*/\n  .CodeMirror-hint div {\n    max-height: none !important;\n  }\n`;\n\ninterface ThemeProp {\n  theme?: string[];\n}\n\nconst makeThemeString = (theme: string[] = []) => [...theme, 'dagit'].join(' ');\n\nexport const StyledReadOnlyCodeMirror = (\n  props: React.ComponentProps<typeof Uncontrolled> & ThemeProp,\n) => {\n  const {options, theme, ...rest} = props;\n  return (\n    <>\n      <DagitCodeMirrorStyle />\n      <Uncontrolled\n        {...rest}\n        options={{...options, readOnly: true, theme: makeThemeString(theme)}}\n      />\n    </>\n  );\n};\n\nexport const StyledCodeMirror = (props: React.ComponentProps<typeof Controlled> & ThemeProp) => {\n  const {options, theme, ...rest} = props;\n  return (\n    <>\n      <DagitCodeMirrorStyle />\n      <Controlled {...rest} options={{...options, theme: makeThemeString(theme)}} />\n    </>\n  );\n};\n","import * as React from 'react';\nimport styled from 'styled-components/macro';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {IconName} from './Icon';\n\ninterface Props {\n  title: React.ReactNode;\n  tags?: React.ReactNode;\n  icon?: IconName;\n  description?: React.ReactNode;\n  metadata?: React.ReactNode;\n  right?: React.ReactNode;\n  tabs?: React.ReactNode;\n}\n\nexport const PageHeader = (props: Props) => {\n  const {title, tags, right, tabs} = props;\n  return (\n    <PageHeaderContainer\n      background={Colors.Gray50}\n      padding={{top: 16, left: 24, right: 12}}\n      border={{side: 'bottom', width: 1, color: Colors.KeylineGray}}\n    >\n      <Box flex={{direction: 'row', justifyContent: 'space-between'}} padding={{bottom: 16}}>\n        <Box flex={{direction: 'row', alignItems: 'flex-start', gap: 12, wrap: 'wrap'}}>\n          {title}\n          {tags}\n        </Box>\n        {right}\n      </Box>\n      {tabs}\n    </PageHeaderContainer>\n  );\n};\n\nconst PageHeaderContainer = styled(Box)`\n  width: 100%;\n\n  /**\n   * Blueprint breadcrumbs annoyingly have a built-in height.\n   */\n  .bp4-breadcrumbs {\n    height: auto;\n  }\n`;\n","import * as React from 'react';\nimport styled, {css} from 'styled-components/macro';\n\nimport {Colors} from './Colors';\nimport {IconWrapper} from './Icon';\nimport {FontFamily} from './styles';\n\nexport interface TabStyleProps {\n  disabled?: boolean;\n  selected?: boolean;\n  count?: number | 'indeterminate' | null;\n  icon?: React.ReactNode;\n  title?: React.ReactNode;\n  $size?: 'small' | 'large';\n}\n\nexport const getTabA11yProps = (props: {selected?: boolean; disabled?: boolean}) => {\n  const {selected, disabled} = props;\n  return {\n    role: 'tab',\n    tabIndex: disabled ? -1 : 0,\n    'aria-disabled': disabled,\n    'aria-expanded': selected,\n    'aria-selected': selected,\n  };\n};\n\nexport const getTabContent = (props: TabStyleProps & {title?: React.ReactNode}) => {\n  const {title, count, icon} = props;\n  return (\n    <>\n      {title}\n      {icon}\n      {count !== undefined ? <Count>{count === 'indeterminate' ? '–' : count}</Count> : null}\n    </>\n  );\n};\n\nconst Count = styled.div`\n  display: inline;\n  font-family: ${FontFamily.monospace};\n  font-size: 14px;\n  font-weight: 500;\n  letter-spacing: -0.02%;\n  padding: 0 4px;\n  color: ${Colors.Gray900};\n  background: ${Colors.Gray100};\n`;\n\nexport const tabCSS = css<TabStyleProps>`\n  background: none;\n  border: none;\n  font-size: 14px;\n  line-height: 20px;\n  font-weight: 600;\n  padding: ${({$size}) => ($size === 'small' ? '10px 0' : '16px 0')};\n  box-shadow: ${({selected}) => (selected ? Colors.Blue500 : 'transparent')} 0 -2px 0 inset;\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  gap: 6px;\n\n  &,\n  & a {\n    cursor: pointer;\n    user-select: none;\n    color: ${({selected, disabled}) =>\n      selected ? Colors.Blue500 : disabled ? Colors.Gray300 : Colors.Gray700};\n  }\n\n  & ${IconWrapper} {\n    color: ${({selected, disabled}) =>\n      selected ? Colors.Blue500 : disabled ? Colors.Gray300 : ''};\n  }\n\n  /* Focus outline only when using keyboard, not when focusing via mouse. */\n  &:focus {\n    outline: none !important;\n    box-shadow: ${({selected, disabled}) =>\n        selected ? Colors.Blue500 : disabled ? 'transparent' : Colors.Blue200}\n      0 -2px 0 inset;\n  }\n\n  &:hover {\n    &,\n    a {\n      text-decoration: none;\n      color: ${({selected, disabled}) =>\n        selected ? Colors.Blue700 : disabled ? Colors.Gray300 : Colors.Blue700};\n    }\n    ${IconWrapper} {\n      color: ${({selected, disabled}) =>\n        selected ? Colors.Blue700 : disabled ? Colors.Gray300 : ''};\n    }\n  }\n`;\n\ninterface TabProps extends TabStyleProps, Omit<React.ComponentPropsWithoutRef<'button'>, 'title'> {}\n\nexport const Tab = styled((props: TabProps) => {\n  const containerProps = getTabA11yProps(props);\n  const content = getTabContent(props);\n\n  const titleText = typeof props.title === 'string' ? props.title : undefined;\n\n  return (\n    <button {...props} {...containerProps} title={titleText} type=\"button\">\n      {content}\n    </button>\n  );\n})<TabStyleProps>`\n  ${tabCSS}\n`;\n\ninterface TabsProps {\n  children: Array<React.ReactElement<TabProps>>;\n  selectedTabId?: string;\n  onChange?: (selectedTabId: string) => void;\n  size?: 'small' | 'large';\n}\n\nexport const Tabs = styled(({selectedTabId, children, onChange, size = 'large', ...rest}) => {\n  return (\n    <div {...rest} role=\"tablist\">\n      {React.Children.map(children, (child) =>\n        child\n          ? React.cloneElement(child, {\n              selected: child.props.selected || child.props.id === selectedTabId,\n              $size: size,\n              ...(onChange\n                ? {\n                    onClick: () => onChange(child.props.id),\n                  }\n                : {}),\n            })\n          : null,\n      )}\n    </div>\n  );\n})<TabsProps>`\n  display: flex;\n  gap: 16px;\n  font-size: ${({size}) => (size === 'small' ? '12px' : '14px')};\n  line-height: ${({size}) => (size === 'small' ? '16px' : '20px')};\n  font-weight: 600;\n`;\n","import * as CodeMirror from 'codemirror';\nimport 'codemirror/addon/hint/show-hint';\nimport 'codemirror/addon/search/search';\nimport 'codemirror/addon/search/searchcursor';\nimport 'codemirror/addon/dialog/dialog';\nimport 'codemirror/addon/dialog/dialog.css';\nimport * as yaml from 'yaml';\n\nimport {\n  ConfigSchema,\n  ConfigSchema_allConfigTypes_CompositeConfigType as CompositeConfigType,\n  ConfigSchema_allConfigTypes_MapConfigType as MapConfigType,\n} from '../types/ConfigSchema';\n\n// Example YAML for testing this parser:\n// https://gist.github.com/bengotow/0b700e7d0367750cb31eaf697f865d70\n\ninterface IParseStateParent {\n  key: string;\n  indent: number;\n  childKeys: string[];\n}\n\nenum ContainerType {\n  Dict = 'dict',\n  List = 'list',\n}\n\ninterface IParseState {\n  trailingSpace: boolean;\n  inlineContainers: ContainerType[];\n  escaped: boolean;\n  inValue: boolean;\n  inBlockLiteral: boolean;\n  inBlockLiteralIndentation: number;\n  parents: IParseStateParent[];\n}\n\n// Helper methods that mutate parser state. These must return new JavaScript objects.\n//\nfunction parentsPoppingItemsDeeperThan(parents: IParseStateParent[], indent: number) {\n  while (parents.length > 0 && parents[parents.length - 1]!.indent >= indent) {\n    parents = parents.slice(0, parents.length - 1);\n  }\n  return parents;\n}\n\nfunction parentsAddingChildKeyToLast(parents: IParseStateParent[], key: string) {\n  if (parents.length === 0) {\n    return [];\n  }\n\n  const immediateParent = parents[parents.length - 1]!;\n  return [\n    ...parents.slice(0, parents.length - 1),\n    {\n      key: immediateParent.key,\n      indent: immediateParent.indent,\n      childKeys: [...immediateParent.childKeys, key],\n    },\n  ];\n}\n\nconst indentMark = (col: number) => {\n  switch (col % 14) {\n    case 0:\n      return 'zero';\n    case 2:\n      return 'one';\n    case 4:\n      return 'two';\n    case 6:\n      return 'three';\n    case 8:\n      return 'four';\n    case 10:\n      return 'five';\n    case 12:\n      return 'six';\n    default:\n      return '';\n  }\n};\n\nfunction parentsAddingChildKeyAtIndent(parents: IParseStateParent[], key: string, indent: number) {\n  parents = parentsPoppingItemsDeeperThan(parents, indent);\n  parents = parentsAddingChildKeyToLast(parents, key);\n  parents = [...parents, {key, indent, childKeys: []}];\n  return parents;\n}\n\nconst Constants = ['true', 'false', 'on', 'off', 'yes', 'no'];\n\nexport const RegExps = {\n  KEYWORD: new RegExp('\\\\b((' + Constants.join(')|(') + '))$', 'i'),\n  DICT_COLON: /^:\\s*/,\n  // eslint-disable-next-line no-useless-escape\n  DICT_KEY: /^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^# ,]*?(?=\\s*:)/,\n  // eslint-disable-next-line no-useless-escape\n  QUOTED_STRING: /^('([^']|\\\\.)*'?|\"([^\"\\\\]|\\\\.)*\"?)/,\n  // eslint-disable-next-line no-useless-escape\n  BLOCKSTART_PIPE_OR_ARROW: /^\\s*(\\||\\>)\\s*/,\n  // eslint-disable-next-line no-useless-escape\n  NUMBER: /^\\s*-?[0-9\\.]+(?![0-9\\.]+)$/,\n  // eslint-disable-next-line no-useless-escape\n  VARIABLE: /^\\s*(\\&|\\*)[a-z0-9\\._-]+$/i,\n};\n\nconst defineYamlMode = () => {\n  CodeMirror.defineMode('yaml', () => {\n    return {\n      lineComment: '#',\n      flattenSpans: false,\n      fold: 'indent',\n      startState: (): IParseState => {\n        return {\n          trailingSpace: false,\n          escaped: false,\n          inValue: false,\n          inBlockLiteral: false,\n          inBlockLiteralIndentation: 0,\n          inlineContainers: [],\n          parents: [],\n        };\n      },\n      token: (stream, state: IParseState) => {\n        const ch = stream.peek();\n        const col = stream.column();\n\n        // reset escape, indent and trailing\n        const wasEscaped = state.escaped;\n        const wasTrailingSpace = state.trailingSpace;\n        state.escaped = false;\n        state.trailingSpace = false;\n\n        // indent\n        if (col % 2 === 0 && ch === ' ' && stream.match(/  /)) {\n          state.trailingSpace = true;\n          return `indent ${indentMark(col)}`;\n        }\n\n        // whitespace\n        const trailingSpace = stream.eatSpace();\n        if (trailingSpace) {\n          state.trailingSpace = true;\n        }\n\n        // escape\n        if (ch === '\\\\') {\n          state.escaped = true;\n          stream.next();\n          return null;\n        }\n\n        // comments\n        // either beginning of the line or had whitespace before\n        if (ch === '#' && (stream.sol() || wasTrailingSpace)) {\n          stream.skipToEnd();\n          return 'comment';\n        }\n\n        if (state.inBlockLiteral) {\n          // continuation of a literal string that was started on a previous line\n          if (stream.indentation() > state.inBlockLiteralIndentation) {\n            stream.skipToEnd();\n            return 'string';\n          }\n          state.inBlockLiteralIndentation = 0;\n          state.inBlockLiteral = false;\n        }\n\n        // array list item, value to follow\n        if (stream.match(/-/)) {\n          state.inValue = true;\n          return 'meta';\n        }\n\n        // doc start / end\n        if (stream.sol()) {\n          state.inValue = false;\n          state.parents = [];\n\n          if (stream.match(/---/) || stream.match(/\\.\\.\\./)) {\n            return 'def';\n          }\n        }\n\n        // Handle inline objects and arrays. These can be nested arbitrarily but we\n        // don't currently support them spanning multiple lines.\n        if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n          if (ch === '{') {\n            state.inlineContainers = [...state.inlineContainers, ContainerType.Dict];\n            state.inValue = false;\n          } else if (ch === '}') {\n            state.inlineContainers = state.inlineContainers.slice(\n              0,\n              state.inlineContainers.length - 1,\n            );\n            state.parents = state.parents.slice(0, state.parents.length - 1);\n            state.inValue = state.inlineContainers.length > 0;\n          } else if (ch === '[') {\n            state.inlineContainers = [...state.inlineContainers, ContainerType.List];\n            state.inValue = true;\n          } else if (ch === ']') {\n            state.inlineContainers = state.inlineContainers.slice(\n              0,\n              state.inlineContainers.length - 1,\n            );\n            state.inValue = state.inlineContainers.length > 0;\n          }\n          state.trailingSpace = false;\n          return 'meta';\n        }\n\n        // Handle inline separators. For dictionaries, we pop from value parsing state back to\n        // key parsing state after a comma and unwind the parent stack.\n        if (state.inlineContainers && !wasEscaped && ch === ',') {\n          const current = state.inlineContainers[state.inlineContainers.length - 1];\n          if (current === ContainerType.Dict) {\n            state.parents = state.parents.slice(0, state.parents.length - 1);\n            state.inValue = false;\n          }\n          stream.next();\n          return 'meta';\n        }\n\n        // A `:` fragment starts value parsing mode if it is not the last character on the line\n        if (stream.match(RegExps.DICT_COLON)) {\n          state.inValue = !stream.eol();\n          return 'meta';\n        }\n\n        // Handle dict key fragments. May be the first element on a line or nested within an inline\n        // (eg: {a: 1, b: 2}). We add the new key to the current `parent` and push a new parent\n        // in case the dict key has subkeys.\n        if (!state.inValue) {\n          const match = stream.match(RegExps.DICT_KEY);\n          if (match) {\n            const key = match[0]!;\n            const keyIndent = stream.pos - key.length;\n            state.parents = parentsAddingChildKeyAtIndent(state.parents, key, keyIndent);\n            return 'atom';\n          }\n        }\n\n        if (state.inValue) {\n          let result = null;\n\n          // Child dicts can start within a value if the user is creating a list, but we don't want to\n          // clasifiy \"my\" as a sub-dict in \"- my:weird:key\". As a balance we require that the colon\n          // be followed by the end-of-line or whitespace.\n          const match = !stream.string.match(/[^\\s]:[^\\s]/)\n            ? stream.match(RegExps.DICT_KEY)\n            : false;\n          if (match) {\n            const key = match[0]!;\n            const keyIndent = stream.pos - key.length;\n            state.inValue = false;\n            state.parents = parentsAddingChildKeyAtIndent(state.parents, key, keyIndent);\n            result = 'atom';\n          }\n\n          if (stream.match(RegExps.BLOCKSTART_PIPE_OR_ARROW)) {\n            state.inBlockLiteralIndentation = stream.indentation();\n            state.inBlockLiteral = true;\n            result = 'meta';\n          }\n\n          if (!result) {\n            // First, read any value that is a quoted string until we reach the end quote.\n            let match = stream.match(RegExps.QUOTED_STRING);\n            if (!match) {\n              // If the value is not a string in quotes, read until a separator (,) or container closing character,\n              // then we'll decide what to do with it.\n              const parentContainer = state.inlineContainers[state.inlineContainers.length - 1];\n              match =\n                parentContainer === ContainerType.List\n                  ? stream.match(/^[^,\\]]+/)\n                  : parentContainer === ContainerType.Dict\n                  ? stream.match(/^[^,\\}]+/)\n                  : stream.match(/^.+$/);\n            }\n            const value = match ? match[0]! : '';\n            if (value.match(RegExps.VARIABLE)) {\n              result = 'variable-2';\n            } else if (value.match(RegExps.NUMBER)) {\n              result = 'number';\n            } else if (value.match(RegExps.KEYWORD)) {\n              result = 'keyword';\n            } else {\n              // \"In YAML, you can write a string without quotes, if it doesn't have a special meaning.\",\n              // so if we can't match the content to any other type and we are inValue, we make it a string.\n              // http://blogs.perl.org/users/tinita/2018/03/strings-in-yaml---to-quote-or-not-to-quote.html\n              result = 'string';\n            }\n          }\n\n          // If after consuming the value and trailing spaces we're at the end of the\n          // line, terminate the value and look for another key on the following line.\n          if (stream.eol() && !state.inBlockLiteral) {\n            state.inValue = false;\n          }\n\n          return result;\n        }\n\n        stream.skipToEnd();\n\n        return null;\n      },\n    };\n  });\n};\n\n// TODO\n// Uniquity of keys\n// add colon\n// add colon and return for composites\n\ntype CodemirrorLocation = {\n  line: number;\n  ch: number;\n};\n\ntype CodemirrorHint = {\n  render: (el: Element, self: any, data: any) => void;\n  text: string;\n  from: CodemirrorLocation;\n  to: CodemirrorLocation;\n};\n\ntype CodemirrorToken = CodeMirror.Token & {\n  state: IParseState;\n};\n\nconst registerYamlHint = () => {\n  CodeMirror.registerHelper(\n    'hint',\n    'yaml',\n    (\n      editor: any,\n      options: {\n        schema?: ConfigSchema;\n      },\n    ): {list: Array<CodemirrorHint>; from: CodemirrorLocation; to: CodemirrorLocation} => {\n      const {\n        cursor,\n        context,\n        token,\n        start,\n        searchString,\n        prevToken,\n      } = expandAutocompletionContextAtCursor(editor);\n\n      const from = {line: cursor.line, ch: start};\n      const to = {line: cursor.line, ch: token.end};\n\n      if (!options.schema) {\n        return {list: [], from, to};\n      }\n\n      if (!context) {\n        return {list: [], from, to};\n      }\n\n      // Since writing meaningful tests for this functionality is difficult given a) no jsdom\n      // support for APIs that codemirror uses (and so no way to use snapshot tests) and b) no\n      // appetite (yet) for writing Selenium tests, we record here the manual tests used to verify\n      // this logic. In what follows, | represents the position of the cursor and -> the transition\n      // on accepting an autocomplete suggestion for `storage: filesystem:\n\n      // st|\n      // ->\n      // storage:\n      //   |\n\n      // storage:|\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage: |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage:  |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      // storage:\n      //   |\n      // ->\n      // storage:\n      //   filesystem:\n      //     |\n\n      const isCompOrList = (key: string): boolean => {\n        if (!options.schema) {\n          return false;\n        }\n        // Using a lookup table here seems like a good idea\n        // https://github.com/dagster-io/dagster/issues/1966\n        let type = options.schema.allConfigTypes.find((t) => t.key === key);\n        if (!type) {\n          return false;\n        }\n\n        // If nullable, extract the inner type.\n        if (type.__typename === 'NullableConfigType') {\n          const innerKey = type.typeParamKeys[0];\n          type = options.schema.allConfigTypes.find((t) => t.key === innerKey);\n          if (!type) {\n            return false;\n          }\n        }\n\n        return (\n          type.__typename === 'ArrayConfigType' ||\n          type.__typename === 'CompositeConfigType' ||\n          type.__typename === 'MapConfigType'\n        );\n      };\n\n      const formatReplacement = (\n        field: any,\n        start: any,\n        token: CodemirrorToken,\n        prevToken: CodemirrorToken,\n        inList: boolean,\n      ) => {\n        let replacement = `${field.name}`;\n        let postReplacementIndentation = start;\n\n        const listMarkerPresent = prevToken.string === ' ' || prevToken.string === '-';\n        if (inList && !listMarkerPresent) {\n          replacement = `- ${replacement}`;\n          postReplacementIndentation += 2;\n        }\n\n        const cursorAtColon = token.string.startsWith(':');\n        if (cursorAtColon) {\n          const nextLineIndent = prevToken.start + 2;\n          replacement = `\\n${' '.repeat(nextLineIndent)}${replacement}`;\n          postReplacementIndentation = nextLineIndent;\n        }\n\n        const completionHasChildren = isCompOrList(field.configTypeKey);\n        if (completionHasChildren) {\n          replacement += `:\\n${' '.repeat(postReplacementIndentation + 2)}`;\n        } else {\n          replacement += ': ';\n        }\n\n        return replacement;\n      };\n\n      const buildSuggestion = (\n        display: string,\n        replacement: string,\n        description: string | null,\n      ): CodemirrorHint => ({\n        text: replacement,\n        render: (el) => {\n          const div = document.createElement('div');\n          div.textContent = display;\n          if (description) {\n            const docs = document.createElement('div');\n            docs.innerText =\n              description.length < 90 ? description : description.substr(0, 87) + '...';\n            docs.style.opacity = '0.5';\n            docs.style.overflow = 'hidden';\n            docs.style.maxHeight = '33px';\n            docs.style.maxWidth = '360px';\n            docs.style.whiteSpace = 'normal';\n            div.appendChild(docs);\n          }\n          el.appendChild(div);\n        },\n        from,\n        to,\n      });\n\n      // Calculate if this is on a new-line child of a scalar union type, as an indication that we\n      // should autocomplete the selector fields of the scalar union\n      const isScalarUnionNewLine =\n        context.type.__typename === 'ScalarUnionConfigType' && !prevToken.end;\n\n      // The context will have available fields if the type is a composite config type OR a scalar\n      // union type\n      if (\n        context.availableFields.length &&\n        (context.type.__typename === 'CompositeConfigType' || isScalarUnionNewLine)\n      ) {\n        return {\n          list: context.availableFields\n            .filter((field) => field.name.startsWith(searchString))\n            .map((field) =>\n              buildSuggestion(\n                field.name,\n                formatReplacement(field, start, token, prevToken, context.inArray),\n                field.description,\n              ),\n            ),\n          from,\n          to,\n        };\n      }\n\n      // Completion of enum field values\n      if (context.type.__typename === 'EnumConfigType') {\n        const searchWithoutQuotes = searchString.startsWith('\"')\n          ? searchString.substr(1)\n          : searchString;\n        return {\n          list: context.type.values\n            .filter((val) => val.value.startsWith(searchWithoutQuotes))\n            .map((val) => buildSuggestion(val.value, `\"${val.value}\"`, null)),\n          from,\n          to,\n        };\n      }\n\n      // Completion of boolean field values\n      if (context.type.__typename === 'RegularConfigType' && context.type.givenName === 'Bool') {\n        return {\n          list: ['True', 'False']\n            .filter((val) => val.startsWith(searchString))\n            .map((val) => buildSuggestion(val, val, null)),\n          from,\n          to,\n        };\n      }\n\n      // Completion of Scalar Union field values, the union of the scalar suggestions and the\n      // non-scalar suggestions\n      const type = context.type;\n      if (type.__typename === 'ScalarUnionConfigType') {\n        const scalarType = options.schema.allConfigTypes.find((x) => x.key === type.scalarTypeKey);\n        const nonScalarType = options.schema.allConfigTypes.find(\n          (x) => x.key === type.nonScalarTypeKey,\n        );\n        let scalarSuggestions: CodemirrorHint[] = [];\n        if (\n          scalarType &&\n          scalarType.__typename === 'RegularConfigType' &&\n          scalarType.givenName === 'Bool'\n        ) {\n          scalarSuggestions = ['True', 'False']\n            .filter((val) => val.startsWith(searchString))\n            .map((val) => buildSuggestion(val, val, null));\n        }\n        let nonScalarSuggestions: CodemirrorHint[] = [];\n        if (nonScalarType && nonScalarType.__typename === 'CompositeConfigType') {\n          nonScalarSuggestions = nonScalarType.fields\n            .filter((field) => field.name.startsWith(searchString))\n            .map((field) =>\n              buildSuggestion(\n                field.name,\n                formatReplacement(field, start, token, prevToken, false),\n                field.description,\n              ),\n            );\n        }\n\n        return {list: [...scalarSuggestions, ...nonScalarSuggestions], from, to};\n      }\n\n      return {list: [], from, to};\n    },\n  );\n};\n\n/** Takes the pipeline schema and the YAML tokenizer state and returns the\n * type in scope and available (yet-to-be-used) fields\n * if it is a composite type.\n */\nfunction findAutocompletionContext(\n  schema: ConfigSchema | null,\n  parents: IParseStateParent[],\n  currentIndent: number,\n) {\n  parents = parents.filter(({indent}) => currentIndent > indent);\n  const immediateParent = parents[parents.length - 1];\n\n  if (!schema) {\n    // Schema may still be loading\n    return;\n  }\n\n  // We only provide autocompletion if the root type is a Map or a composite (Shape)\n  let type = schema.allConfigTypes.find((t) => t.key === schema.rootConfigType.key);\n  if (!type || (type.__typename !== 'CompositeConfigType' && type.__typename !== 'MapConfigType')) {\n    return null;\n  }\n\n  let available = type.__typename === 'CompositeConfigType' ? type.fields : [];\n\n  // Tracks the nearest mapping type (Shape, Map, etc.) in the hierarchy to the cursor\n  // This is what's rendered in the schema sidebar\n  let closestMappingType: MapConfigType | CompositeConfigType = type;\n  let inArray = false;\n\n  // Tracks the type key to be used for the next depth level\n  // Used for Map config types, which specify the type key for their values, otherwise is null\n  let nextTypeKey: string | null =\n    type.__typename === 'MapConfigType' ? type.typeParamKeys[1]! : null;\n\n  if ((available || type.__typename === 'MapConfigType') && parents.length > 0) {\n    for (const parent of parents) {\n      // In order to provide completion, we must either have type information on hand (parentTypeDef)\n      // for the current key that we are in, or we must have the type info provided by an enclosing Map (nextTypeKey)\n      const parentTypeDef = available.find(({name}) => parent.key === name);\n      if (!parentTypeDef && !nextTypeKey) {\n        return null;\n      }\n\n      // The current composite type's available \"fields\" each only have a configType key.\n      // The rest of the configType's information is in the top level schema.allConfigTypes\n      // to avoid superlinear GraphQL response size.\n      const typeKey = nextTypeKey ? nextTypeKey : parentTypeDef?.configTypeKey;\n      nextTypeKey = null;\n\n      let parentConfigType = schema.allConfigTypes.find((t) => t.key === typeKey)!;\n\n      // If nullable, extract the inner type.\n      if (parentConfigType.__typename === 'NullableConfigType') {\n        const innerType = parentConfigType.typeParamKeys[0];\n        parentConfigType = schema.allConfigTypes.find((t) => t.key === innerType)!;\n      }\n\n      let childTypeKey = parentConfigType.key;\n      let childEntriesUnique = true;\n\n      inArray = parentConfigType.__typename === 'ArrayConfigType';\n      if (inArray) {\n        childTypeKey = parentConfigType.typeParamKeys[0]!;\n        childEntriesUnique = false;\n      }\n\n      // Maps provide no direct autocompletions, but they do act as the closestMappingType,\n      // meaning they show up in the schema sidebar\n      if (parentConfigType.__typename === 'MapConfigType') {\n        nextTypeKey = parentConfigType.typeParamKeys[1]!;\n        closestMappingType = parentConfigType;\n        available = [];\n        continue;\n      }\n\n      type = schema.allConfigTypes.find((t) => t.key === childTypeKey);\n      if (!type) {\n        return null;\n      }\n\n      if (type.__typename === 'ScalarUnionConfigType') {\n        available = [];\n        const nonScalarTypeKey = type.nonScalarTypeKey;\n        const nonScalarType = schema.allConfigTypes.find((x) => x.key === nonScalarTypeKey);\n        if (nonScalarType && nonScalarType.__typename === 'CompositeConfigType') {\n          available = nonScalarType.fields;\n        }\n      } else if (type.__typename === 'CompositeConfigType') {\n        closestMappingType = type;\n        available = type.fields;\n\n        if (parent === immediateParent && childEntriesUnique) {\n          available = available.filter(\n            (item) => immediateParent.childKeys.indexOf(item.name) === -1,\n          );\n        }\n      } else {\n        available = [];\n      }\n    }\n  }\n\n  return {type, closestMappingType, availableFields: available, inArray};\n}\n\n// Find context for a fully- or partially- typed key or value in the YAML document\nexport function expandAutocompletionContextAtCursor(editor: any) {\n  const schema: ConfigSchema = editor.options.hintOptions.schema;\n\n  const cursor = editor.getCursor();\n  const token: CodemirrorToken = editor.getTokenAt(cursor);\n  const prevToken: CodemirrorToken = editor.getTokenAt({\n    line: cursor.line,\n    ch: token.start,\n  });\n\n  let searchString: string;\n  let start: number;\n  if (\n    token.type === 'whitespace' ||\n    token.type?.startsWith('indent ') ||\n    token.string.startsWith(':')\n  ) {\n    searchString = '';\n    start = token.end;\n  } else {\n    searchString = token.string;\n    start = token.start;\n  }\n\n  // Takes the schema and the YAML tokenizer state and returns the\n  // type in scope and available (yet-to-be-used) fields\n  // if it is a composite type.\n  return {\n    start,\n    cursor,\n    searchString,\n    token,\n    prevToken,\n    context: findAutocompletionContext(schema, token.state.parents, start),\n  };\n}\n\ntype CodemirrorLintError = {\n  message: string;\n  severity: 'error' | 'warning' | 'information' | 'hint';\n  type: 'validation' | 'syntax' | 'deprecation';\n  from: CodemirrorLocation;\n  to: CodemirrorLocation;\n};\n\nexport type YamlModeValidationResult =\n  | {\n      isValid: true;\n    }\n  | {\n      isValid: false;\n      errors: YamlModeValidationError[];\n    };\n\nexport type YamlModeValidateFunction = (configYaml: string) => Promise<YamlModeValidationResult>;\n\ntype YamlModeValidationError = {\n  message: string;\n  path: string[];\n  reason: string;\n};\n\nCodeMirror.registerHelper('dagster-docs', 'yaml', (editor: any, pos: CodeMirror.Position) => {\n  const token = editor.getTokenAt(pos);\n\n  const schema: ConfigSchema = editor.options.hintOptions.schema;\n\n  if (token.type !== 'atom') {\n    return null;\n  }\n\n  const context = findAutocompletionContext(schema, token.state.parents, token.start);\n  const match =\n    context &&\n    context.type.__typename === 'CompositeConfigType' &&\n    context.type.fields.find((f) => f.name === token.string);\n\n  if (match && match.description) {\n    return match.description;\n  }\n\n  return null;\n});\n\nconst registerYamlLint = () => {\n  CodeMirror.registerHelper(\n    'lint',\n    'yaml',\n    async (\n      text: string,\n      {checkConfig}: {checkConfig: YamlModeValidateFunction},\n      editor: any,\n    ): Promise<Array<CodemirrorLintError>> => {\n      const codeMirrorDoc = editor.getDoc();\n\n      // TODO: In some scenarios where every line yields an error `parseDocument` can take 1s+\n      // and returns 20,000+ errors. The library does not have a \"bail out\" option but we need one.\n      // However we can't switch libraries because we need the structured document model this returns.\n      // (It's not just text parsed to plain JS objects.)\n      const yamlDoc = yaml.parseDocument(text);\n      const lints: Array<CodemirrorLintError> = [];\n      const lintingTruncated = yamlDoc.errors.length > 10;\n      let lastMarkLocation: CodeMirror.Position | undefined;\n\n      yamlDoc.errors.slice(0, 10).forEach((error) => {\n        const [fromPos, toPos] = error.pos;\n        const from = codeMirrorDoc.posFromIndex(fromPos) as CodeMirror.Position;\n        const to = codeMirrorDoc.posFromIndex(toPos) as CodeMirror.Position;\n\n        if (!lastMarkLocation || lastMarkLocation.line < from.line) {\n          lastMarkLocation = from;\n        }\n\n        lints.push({\n          message: error.message,\n          severity: 'error',\n          type: 'syntax',\n          from,\n          to,\n        });\n      });\n\n      if (lintingTruncated && lastMarkLocation) {\n        const nextLineLocation: CodeMirror.Position = {\n          line: lastMarkLocation.line + 1,\n          ch: 0,\n        };\n        lints.push({\n          message: `${yamlDoc.errors.length - lints.length} more errors - bailed out.`,\n          severity: 'warning',\n          type: 'syntax',\n          from: nextLineLocation,\n          to: nextLineLocation,\n        });\n      }\n\n      if (yamlDoc.errors.length === 0) {\n        const validationResult = await checkConfig(text);\n        if (!validationResult.isValid) {\n          validationResult.errors.forEach((error) => {\n            const lint = validationErrorToCodemirrorError(error, yamlDoc, codeMirrorDoc);\n            if (lint) {\n              lints.push(lint);\n            }\n          });\n        }\n      }\n\n      return lints;\n    },\n  );\n};\n\nfunction validationErrorToCodemirrorError(\n  error: YamlModeValidationError,\n  yamlDoc: yaml.Document,\n  codeMirrorDoc: any,\n): CodemirrorLintError | null {\n  const part = error.reason === 'RUNTIME_TYPE_MISMATCH' ? 'value' : 'key';\n  const range = findRangeInDocumentFromPath(yamlDoc, error.path, part);\n  if (range === null) {\n    return null;\n  }\n  return {\n    message: error.message,\n    severity: 'error',\n    type: 'syntax',\n    from: codeMirrorDoc.posFromIndex(range ? range.start : 0) as CodeMirror.Position,\n    to: codeMirrorDoc.posFromIndex(\n      range ? range.end : Number.MAX_SAFE_INTEGER,\n    ) as CodeMirror.Position,\n  };\n}\n\nexport function findRangeInDocumentFromPath(\n  doc: yaml.Document,\n  path: Array<string>,\n  pathPart: 'key' | 'value',\n): {start: number; end: number} | null {\n  let node = nodeAtPath(doc, path);\n  if (!node || !('type' in node)) {\n    return null;\n  }\n\n  if (node.type === 'PAIR') {\n    if (pathPart === 'value' && node.value) {\n      node = node.value;\n    } else {\n      node = node.key;\n    }\n  }\n\n  if (node && node.range) {\n    return {\n      start: node.range[0],\n      end: node.range[1],\n    };\n  } else {\n    return null;\n  }\n}\n\nfunction nodeAtPath(doc: yaml.Document, path: Array<string>) {\n  let node: any = doc.contents;\n  for (let i = 0; i < path.length; i++) {\n    const part = path[i]!;\n    if (node && node.type && node.type === 'PAIR') {\n      node = node.value;\n    }\n\n    if (node && node.type && (node.type === 'SEQ' || node.type === 'FLOW_SEQ')) {\n      const index = Number.parseInt(part);\n      if (!Number.isNaN(index)) {\n        node = node.items[index];\n      } else {\n        return null;\n      }\n    } else if (node && node.type && (node.type === 'FLOW_MAP' || node.type === 'MAP')) {\n      const item = node.items.find(({key}: {key: any}) => key.value === part);\n      if (item && item.type && item.type === 'PAIR') {\n        node = item;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  return node;\n}\n\nexport const registerYaml = () => {\n  defineYamlMode();\n  registerYamlHint();\n  registerYamlLint();\n};\n"],"names":["useDocumentTitle","title","React","currentTitle","document","registerYaml","DagitCodeMirrorStyle","createGlobalStyle","FontFamily","Colors","Icons","makeThemeString","theme","join","StyledReadOnlyCodeMirror","props","options","rest","readOnly","StyledCodeMirror","PageHeader","tags","right","tabs","PageHeaderContainer","background","padding","top","left","border","side","width","color","flex","direction","justifyContent","bottom","alignItems","gap","wrap","styled","Box","getTabA11yProps","selected","disabled","role","tabIndex","getTabContent","count","icon","undefined","Count","tabCSS","css","$size","IconWrapper","Tab","containerProps","content","titleText","type","Tabs","selectedTabId","children","onChange","size","child","id","onClick","ContainerType","parentsAddingChildKeyAtIndent","parents","key","indent","length","slice","parentsPoppingItemsDeeperThan","immediateParent","childKeys","parentsAddingChildKeyToLast","RegExps","KEYWORD","RegExp","DICT_COLON","DICT_KEY","QUOTED_STRING","BLOCKSTART_PIPE_OR_ARROW","NUMBER","VARIABLE","registerYamlHint","CodeMirror","editor","expandAutocompletionContextAtCursor","cursor","context","token","start","searchString","prevToken","from","line","ch","to","end","schema","list","formatReplacement","field","inList","replacement","name","postReplacementIndentation","listMarkerPresent","string","startsWith","nextLineIndent","repeat","completionHasChildren","allConfigTypes","find","t","__typename","innerKey","typeParamKeys","isCompOrList","configTypeKey","buildSuggestion","display","description","text","render","el","div","createElement","textContent","docs","innerText","substr","style","opacity","overflow","maxHeight","maxWidth","whiteSpace","appendChild","isScalarUnionNewLine","availableFields","filter","map","inArray","searchWithoutQuotes","values","val","value","givenName","scalarType","x","scalarTypeKey","nonScalarType","nonScalarTypeKey","scalarSuggestions","nonScalarSuggestions","fields","findAutocompletionContext","currentIndent","rootConfigType","available","closestMappingType","nextTypeKey","parent","parentTypeDef","typeKey","parentConfigType","innerType","childTypeKey","childEntriesUnique","item","indexOf","hintOptions","getCursor","getTokenAt","state","pos","match","f","validationErrorToCodemirrorError","error","yamlDoc","codeMirrorDoc","part","reason","range","findRangeInDocumentFromPath","path","message","severity","posFromIndex","Number","MAX_SAFE_INTEGER","doc","pathPart","node","contents","i","index","parseInt","isNaN","items","nodeAtPath","lineComment","flattenSpans","fold","startState","trailingSpace","escaped","inValue","inBlockLiteral","inBlockLiteralIndentation","inlineContainers","stream","peek","col","column","wasEscaped","wasTrailingSpace","indentMark","eatSpace","next","sol","skipToEnd","indentation","Dict","List","eol","keyIndent","result","parentContainer","checkConfig","getDoc","yaml","lints","lintingTruncated","errors","forEach","fromPos","toPos","lastMarkLocation","push","nextLineLocation","validationResult","isValid","lint"],"sourceRoot":""}