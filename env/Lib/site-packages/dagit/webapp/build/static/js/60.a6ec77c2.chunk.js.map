{"version":3,"file":"static/js/60.a6ec77c2.chunk.js","mappings":"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","sources":["../../core/src/hooks/useQueryPersistedState.tsx","../../core/src/pipelines/PipelineReference.tsx","../../core/src/runs/RunStatuses.tsx","../../core/src/runs/RunsFilterInput.tsx","../../ui/src/components/NonIdealState.tsx","../../ui/src/components/TokenizingField.tsx"],"sourcesContent":["import isEqual from 'lodash/isEqual';\nimport qs from 'qs';\nimport React from 'react';\nimport {useHistory, useLocation} from 'react-router-dom';\n\ntype QueryPersistedDataType =\n  | {[key: string]: any}\n  | Array<any>\n  | (string | undefined | number)\n  | (boolean | undefined)\n  | null;\n\nlet currentQueryString: {[key: string]: any} = {};\n\nexport type QueryPersistedStateConfig<T extends QueryPersistedDataType> = {\n  queryKey?: string;\n  defaults?: {[key: string]: any};\n  decode?: (raw: {[key: string]: any}) => T;\n  encode?: (raw: T) => {[key: string]: any};\n};\n\n/**\n * This goal of this hook is to make it easy to replace `React.useState` with a version\n * that persists the value to the page querystring so it is saved across page reload, etc.\n * Hopefully by making it easy, we'll do this often and improve overall UX.\n *\n * Examples:\n *\n * // Single (string | undefined) key saved to querystring with default value applied inline\n *\n * const [search = '', setSearch] = useQueryPersistedState({queryKey: 'q'})\n *\n * // Object saved to querystring with default values pre-filled\n * // Note: String and boolean values are automatically encoded / decoded, see below for others\n *\n * const [query, setQuery] = useQueryPersistedState<{cursor: string, filter: string}>({\n *   defaults: {cursor: '', filter: ''},\n * })\n *\n * // Custom transformer mapping to / from querystring representation (for our filter tokens)\n * // Note: `setIdeas` will be a different function on every render unless you memoize the options\n * // passed to the hook! Pull the encode/decode functions out into a file constant or use React.useRef\n *\n * const [ideas, setIdeas] = useQueryPersistedState<string[]>({\n *   encode: (ideas) => ({q: ideas.join(',')}),\n *   decode: ({q}) => (q || '').split(','),\n * })\n *\n * Note: if you combine encode/decode with defaults, the defaults are applied to the query\n * string BEFORE decoding.\n */\nexport function useQueryPersistedState<T extends QueryPersistedDataType>(\n  options: QueryPersistedStateConfig<T>,\n): [T, (updates: T) => void] {\n  const {queryKey, defaults} = options;\n  let {encode, decode} = options;\n\n  if (queryKey) {\n    // Just a short-hand way of providing encode/decode that go from qs object => string\n    if (!encode) {\n      encode = (raw: T) => ({[queryKey]: raw});\n    }\n    if (!decode) {\n      decode = (qs: {[key: string]: any}) => inferTypeOfQueryParam<T>(qs[queryKey]);\n    }\n  }\n\n  const location = useLocation();\n  const history = useHistory();\n\n  // Note: If you have provided defaults and no encoder/decoder, the `value` exposed by\n  // useQueryPersistedState only includes those keys so other params don't leak into your value.\n  const qsDecoded = React.useMemo(() => {\n    // We stash the query string into a ref so that the setter can operate on the /current/\n    // location even if the user retains it and calls it after other query string changes.\n    currentQueryString = qs.parse(location.search, {ignoreQueryPrefix: true});\n\n    const qsWithDefaults = {...(defaults || {}), ...currentQueryString};\n    return decode ? decode(qsWithDefaults) : inferTypeOfQueryParams<T>(qsWithDefaults);\n  }, [location.search, decode, defaults]);\n\n  // If `decode` yields a non-primitive type (eg: object or array), by default we yield\n  // an object with a new identity on every render. To prevent possible render loops caused by\n  // our value as a useEffect dependency, etc., we re-use the last yielded object if it isEqual.\n  const valueRef = React.useRef<T>(qsDecoded);\n  const onChangeRef = React.useCallback<(updated: T) => void>(\n    (updated: T) => {\n      const next = {\n        ...currentQueryString,\n        ...(encode ? encode(updated) : (updated as {[key: string]: any})),\n      };\n\n      // omit any keys that are equal to the defaults to keep URLs minimal\n      for (const [key, value] of Object.entries(next)) {\n        if (options.defaults && options.defaults[key] === value) {\n          delete next[key];\n        }\n      }\n\n      currentQueryString = next;\n\n      history.replace(`${location.pathname}?${qs.stringify(next, {arrayFormat: 'brackets'})}`);\n    },\n    [history, encode, location.pathname, options],\n  );\n\n  if (!isEqual(valueRef.current, qsDecoded)) {\n    valueRef.current = qsDecoded;\n  }\n  return [valueRef.current, onChangeRef];\n}\n\nfunction inferTypeOfQueryParam<T>(q: any): T {\n  return q === 'false' ? false : q === 'true' ? true : q;\n}\n\nfunction inferTypeOfQueryParams<T>(qs: {[key: string]: any}) {\n  const result: {[key: string]: any} = {};\n  for (const key of Object.keys(qs)) {\n    result[key] = inferTypeOfQueryParam<any>(qs[key]);\n  }\n  return result as T;\n}\n","import {Box, Colors, Icon} from '@dagster-io/ui';\nimport * as React from 'react';\nimport {Link} from 'react-router-dom';\n\nimport {RepoAddress} from '../workspace/types';\nimport {workspacePipelinePath, workspacePipelinePathGuessRepo} from '../workspace/workspacePath';\n\nimport {PipelineSnapshotLink} from './PipelinePathUtils';\n\nexport interface Props {\n  pipelineName: string;\n  pipelineHrefContext: 'repo-unknown' | RepoAddress | 'no-link';\n  isJob: boolean;\n  snapshotId?: string | null;\n  showIcon?: boolean;\n  truncationThreshold?: number;\n  size?: 'small' | 'normal';\n}\n\nconst DEFAULT_TRUNCATION_THRESHOLD = 40;\nconst TRUNCATION_BUFFER = 5;\n\nexport const PipelineReference: React.FC<Props> = ({\n  pipelineName,\n  pipelineHrefContext,\n  isJob,\n  snapshotId,\n  showIcon,\n  truncationThreshold = DEFAULT_TRUNCATION_THRESHOLD,\n  size = 'normal',\n}) => {\n  const truncatedName =\n    truncationThreshold > 0 && pipelineName.length > truncationThreshold\n      ? `${pipelineName.slice(0, truncationThreshold - TRUNCATION_BUFFER)}…`\n      : pipelineName;\n\n  const pipeline =\n    pipelineHrefContext === 'repo-unknown' ? (\n      <Link to={workspacePipelinePathGuessRepo(pipelineName, isJob)}>{truncatedName}</Link>\n    ) : pipelineHrefContext === 'no-link' ? (\n      <>{truncatedName}</>\n    ) : (\n      <Link\n        to={workspacePipelinePath({\n          repoName: pipelineHrefContext.name,\n          repoLocation: pipelineHrefContext.location,\n          pipelineName,\n          isJob,\n        })}\n      >\n        {truncatedName}\n      </Link>\n    );\n\n  return (\n    <Box flex={{direction: 'row', alignItems: 'center', display: 'inline-flex'}}>\n      {showIcon && (\n        <Box margin={{right: 8}}>\n          <Icon color={Colors.Gray400} name=\"job\" />\n        </Box>\n      )}\n      <span>\n        {pipeline}\n        {snapshotId && ' @ '}\n        {snapshotId && (\n          <PipelineSnapshotLink snapshotId={snapshotId} pipelineName={pipelineName} size={size} />\n        )}\n      </span>\n    </Box>\n  );\n};\n","import {RunStatus} from '../graphql/types';\n\nexport const queuedStatuses = new Set([RunStatus.QUEUED]);\n\nexport const inProgressStatuses = new Set([\n  RunStatus.STARTED,\n  RunStatus.STARTING,\n  RunStatus.CANCELING,\n]);\n\nexport const successStatuses = new Set([RunStatus.SUCCESS]);\nexport const failedStatuses = new Set([RunStatus.FAILURE, RunStatus.CANCELED]);\n\nexport const doneStatuses = new Set([RunStatus.FAILURE, RunStatus.SUCCESS, RunStatus.CANCELED]);\n\nexport const cancelableStatuses = new Set([RunStatus.QUEUED, RunStatus.STARTED]);\n","import {gql, useLazyQuery} from '@apollo/client';\nimport {\n  SuggestionProvider,\n  TokenizingField,\n  TokenizingFieldValue,\n  tokensAsStringArray,\n  tokenizedValuesFromStringArray,\n} from '@dagster-io/ui';\nimport qs from 'qs';\nimport * as React from 'react';\n\nimport {RunsFilter, RunStatus} from '../graphql/types';\nimport {useQueryPersistedState} from '../hooks/useQueryPersistedState';\nimport {DagsterRepoOption, useRepositoryOptions} from '../workspace/WorkspaceContext';\n\nimport {\n  RunTagKeysQuery,\n  RunTagValuesQuery,\n  RunTagValuesQueryVariables,\n} from './types/RunsFilterInput.types';\n\ntype RunTags = Array<{\n  __typename: 'PipelineTagAndValues';\n  key: string;\n  values: Array<string>;\n}>;\n\nexport type RunFilterTokenType = 'id' | 'status' | 'pipeline' | 'job' | 'snapshotId' | 'tag';\n\nexport type RunFilterToken = {\n  token?: RunFilterTokenType;\n  value: string;\n};\n\nconst RUN_PROVIDERS_EMPTY = [\n  {\n    token: 'id',\n    values: () => [],\n  },\n  {\n    token: 'status',\n    values: () => [],\n  },\n  {\n    token: 'pipeline',\n    values: () => [],\n  },\n  {\n    token: 'job',\n    values: () => [],\n  },\n  {\n    token: 'tag',\n    values: () => [],\n  },\n  {\n    token: 'snapshotId',\n    values: () => [],\n  },\n];\n\n/**\n * This React hook provides run filtering state similar to React.useState(), but syncs\n * the value to the URL query string so that reloading the page / navigating \"back\"\n * maintains your view as expected.\n *\n * @param enabledFilters: This is useful if you want to ignore some filters that could\n * be provided (eg pipeline:, which is not relevant within pipeline scoped views.)\n */\nexport function useQueryPersistedRunFilters(enabledFilters?: RunFilterTokenType[]) {\n  return useQueryPersistedState<RunFilterToken[]>(\n    React.useMemo(\n      () => ({\n        encode: (tokens) => ({q: tokensAsStringArray(tokens), cursor: undefined}),\n        decode: ({q = []}) =>\n          tokenizedValuesFromStringArray(q, RUN_PROVIDERS_EMPTY).filter(\n            (t) =>\n              !t.token || !enabledFilters || enabledFilters.includes(t.token as RunFilterTokenType),\n          ) as RunFilterToken[],\n      }),\n      [enabledFilters],\n    ),\n  );\n}\n\nexport function runsPathWithFilters(filterTokens: RunFilterToken[]) {\n  return `/runs?${qs.stringify({q: tokensAsStringArray(filterTokens)}, {arrayFormat: 'brackets'})}`;\n}\n\nexport function runsFilterForSearchTokens(search: TokenizingFieldValue[]) {\n  if (!search[0]) {\n    return {};\n  }\n\n  const obj: RunsFilter = {};\n\n  for (const item of search) {\n    if (item.token === 'pipeline' || item.token === 'job') {\n      obj.pipelineName = item.value;\n    } else if (item.token === 'id') {\n      obj.runIds = obj.runIds || [];\n      obj.runIds.push(item.value);\n    } else if (item.token === 'status') {\n      obj.statuses = obj.statuses || [];\n      obj.statuses.push(item.value as RunStatus);\n    } else if (item.token === 'snapshotId') {\n      obj.snapshotId = item.value;\n    } else if (item.token === 'tag') {\n      const [key, value = ''] = item.value.split('=');\n      if (obj.tags) {\n        obj.tags.push({key, value});\n      } else {\n        obj.tags = [{key, value}];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction searchSuggestionsForRuns(\n  repositoryOptions: DagsterRepoOption[],\n  runTagKeys?: string[],\n  selectedRunTagKey?: string,\n  runTagValues?: RunTags,\n  enabledFilters?: RunFilterTokenType[],\n): SuggestionProvider[] {\n  const pipelineNames = new Set<string>();\n  const jobNames = new Set<string>();\n\n  for (const option of repositoryOptions) {\n    const {repository} = option;\n    for (const pipeline of repository.pipelines) {\n      if (pipeline.isJob) {\n        jobNames.add(pipeline.name);\n      } else {\n        pipelineNames.add(pipeline.name);\n      }\n    }\n  }\n\n  const suggestions: {token: RunFilterTokenType; values: () => string[]; textOnly?: boolean}[] = [\n    {\n      token: 'id',\n      values: () => [],\n    },\n    {\n      token: 'status',\n      values: () => Object.keys(RunStatus),\n    },\n    {\n      token: 'pipeline',\n      values: () => Array.from(pipelineNames),\n    },\n    {\n      token: 'job',\n      values: () => Array.from(jobNames),\n    },\n    {\n      token: 'tag',\n      values: () => {\n        if (!selectedRunTagKey) {\n          return (runTagKeys || []).map((key) => `${key}`);\n        }\n        return (runTagValues || [])\n          .filter(({key}) => key === selectedRunTagKey)\n          .map(({values}) => values.map((value) => `${selectedRunTagKey}=${value}`))\n          .flat();\n      },\n      textOnly: !selectedRunTagKey,\n    },\n    {\n      token: 'snapshotId',\n      values: () => [],\n    },\n  ];\n\n  if (enabledFilters) {\n    return suggestions.filter((x) => enabledFilters.includes(x.token));\n  }\n\n  return suggestions;\n}\n\ninterface RunsFilterInputProps {\n  loading?: boolean;\n  tokens: RunFilterToken[];\n  onChange: (tokens: RunFilterToken[]) => void;\n  enabledFilters?: RunFilterTokenType[];\n}\n\nexport const RunsFilterInput: React.FC<RunsFilterInputProps> = ({\n  loading,\n  tokens,\n  onChange,\n  enabledFilters,\n}) => {\n  const {options} = useRepositoryOptions();\n  const [selectedTagKey, setSelectedTagKey] = React.useState<string | undefined>();\n  const [fetchTagKeys, {data: tagKeyData}] = useLazyQuery<RunTagKeysQuery>(RUN_TAG_KEYS_QUERY);\n  const [fetchTagValues, {data: tagValueData}] = useLazyQuery<\n    RunTagValuesQuery,\n    RunTagValuesQueryVariables\n  >(RUN_TAG_VALUES_QUERY, {\n    variables: {tagKeys: selectedTagKey ? [selectedTagKey] : []},\n  });\n\n  React.useEffect(() => {\n    if (selectedTagKey) {\n      fetchTagValues();\n    }\n  }, [selectedTagKey, fetchTagValues]);\n\n  const suggestions = searchSuggestionsForRuns(\n    options,\n    tagKeyData?.runTagKeysOrError?.__typename === 'RunTagKeys'\n      ? tagKeyData.runTagKeysOrError.keys\n      : [],\n    selectedTagKey,\n    tagValueData?.runTagsOrError?.__typename === 'RunTags' ? tagValueData.runTagsOrError.tags : [],\n    enabledFilters,\n  );\n\n  const search = tokenizedValuesFromStringArray(tokensAsStringArray(tokens), suggestions);\n  const refreshSuggestions = (text: string) => {\n    if (!text.startsWith('tag:')) {\n      return;\n    }\n    const tagKeyText = text.slice(4);\n    if (\n      tagKeyData?.runTagKeysOrError?.__typename === 'RunTagKeys' &&\n      tagKeyData.runTagKeysOrError.keys.includes(tagKeyText)\n    ) {\n      setSelectedTagKey(tagKeyText);\n    }\n  };\n\n  const suggestionProvidersFilter = (\n    suggestionProviders: SuggestionProvider[],\n    values: TokenizingFieldValue[],\n  ) => {\n    const tokens: string[] = [];\n    for (const {token} of values) {\n      if (token) {\n        tokens.push(token);\n      }\n    }\n\n    // If id is set, then no other filters can be set\n    if (tokens.includes('id')) {\n      return [];\n    }\n\n    // Can only have one filter value for pipeline or id\n    const limitedTokens = new Set<string>(['id', 'job', 'pipeline', 'snapshotId']);\n    const presentLimitedTokens = tokens.filter((token) => limitedTokens.has(token));\n\n    return suggestionProviders.filter(\n      (provider) => !provider.token || !presentLimitedTokens.includes(provider.token),\n    );\n  };\n\n  const onFocus = React.useCallback(() => fetchTagKeys(), [fetchTagKeys]);\n\n  return (\n    <TokenizingField\n      values={search}\n      onChange={(values) => onChange(values as RunFilterToken[])}\n      onFocus={onFocus}\n      onTextChange={refreshSuggestions}\n      suggestionProviders={suggestions}\n      suggestionProvidersFilter={suggestionProvidersFilter}\n      loading={loading}\n    />\n  );\n};\n\nconst RUN_TAG_KEYS_QUERY = gql`\n  query RunTagKeysQuery {\n    runTagKeysOrError {\n      ... on RunTagKeys {\n        keys\n      }\n    }\n  }\n`;\n\nconst RUN_TAG_VALUES_QUERY = gql`\n  query RunTagValuesQuery($tagKeys: [String!]!) {\n    runTagsOrError(tagKeys: $tagKeys) {\n      __typename\n      ... on RunTags {\n        tags {\n          key\n          values\n        }\n      }\n    }\n  }\n`;\n","import * as React from 'react';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {IconName, Icon} from './Icon';\nimport {Spinner} from './Spinner';\nimport {Subheading} from './Text';\n\nexport type NonIdealStateProps = React.DetailedHTMLProps<\n  React.InputHTMLAttributes<HTMLInputElement>,\n  HTMLInputElement\n> & {\n  icon: 'error' | 'no-results' | 'spinner' | IconName;\n  title: string;\n  description?: React.ReactNode;\n  action?: React.ReactNode;\n  shrinkable?: boolean;\n};\n\nexport const NonIdealState: React.FC<NonIdealStateProps> = ({\n  title,\n  description,\n  icon,\n  action,\n  shrinkable,\n}) => {\n  const singleContentElement = [title, description, action].filter(Boolean).length === 1;\n\n  return (\n    <Box\n      flex={{gap: 20, alignItems: singleContentElement ? 'center' : 'flex-start'}}\n      background={Colors.Gray50}\n      padding={24}\n      style={{\n        margin: 'auto',\n        borderRadius: 8,\n        width: shrinkable ? 'initial' : 'max-content',\n        maxWidth: 500,\n      }}\n    >\n      {icon === 'spinner' ? (\n        <Spinner purpose=\"section\" />\n      ) : icon === 'no-results' ? (\n        <Icon name=\"search\" size={48} color={Colors.Gray400} />\n      ) : (\n        <Icon name={icon} size={48} color={Colors.Gray400} />\n      )}\n      <Box\n        flex={{\n          gap: 8,\n          direction: 'column',\n          alignItems: 'flex-start',\n        }}\n      >\n        {title && <Subheading style={{color: Colors.Gray900}}>{title}</Subheading>}\n        {description && <div style={{color: Colors.Gray500}}>{description}</div>}\n        {action}\n      </Box>\n    </Box>\n  );\n};\n","// eslint-disable-next-line no-restricted-imports\nimport {TagInput} from '@blueprintjs/core';\nimport * as React from 'react';\nimport styled from 'styled-components/macro';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {MenuItem, Menu} from './Menu';\nimport {Popover} from './Popover';\nimport {Spinner} from './Spinner';\n\nconst MAX_SUGGESTIONS = 100;\n\nexport interface SuggestionProvider {\n  token?: string;\n  values: () => string[];\n  suggestionFilter?: (query: string, suggestion: Suggestion) => boolean;\n  textOnly?: boolean;\n}\n\nexport interface Suggestion {\n  text: string;\n  final: boolean;\n}\n\ninterface ActiveSuggestionInfo {\n  text: string;\n  idx: number;\n}\n\nexport interface TokenizingFieldValue {\n  token?: string;\n  value: string;\n}\n\ninterface TokenizingFieldProps {\n  values: TokenizingFieldValue[];\n  maxValues?: number;\n  onChange: (values: TokenizingFieldValue[]) => void;\n  onChangeBeforeCommit?: boolean;\n  addOnBlur?: boolean;\n  onFocus?: () => void;\n\n  placeholder?: string;\n  loading?: boolean;\n  className?: string;\n  small?: boolean;\n\n  fullwidth?: boolean;\n\n  onTextChange?: (text: string) => void;\n  suggestionProviders: SuggestionProvider[];\n  suggestionRenderer?: (suggestion: Suggestion) => React.ReactNode;\n  suggestionProvidersFilter?: (\n    suggestionProvider: SuggestionProvider[],\n    values: TokenizingFieldValue[],\n  ) => SuggestionProvider[];\n}\n\nfunction findProviderByToken(token: string, providers: SuggestionProvider[]) {\n  return providers.find((p) => p.token && p.token.toLowerCase() === token.toLowerCase());\n}\n\nexport const tokenizedValuesFromString = (str: string, providers: SuggestionProvider[]) => {\n  if (str === '') {\n    return [];\n  }\n  const tokens = str.split(',');\n  return tokenizedValuesFromStringArray(tokens, providers);\n};\n\nexport const tokenizedValuesFromStringArray = (tokens: string[], providers: SuggestionProvider[]) =>\n  tokens.map((token) => tokenizedValueFromString(token, providers));\n\nexport const tokenizeString = (str: string): [string, string] => {\n  const colonAt = str.indexOf(':');\n  if (colonAt === -1) {\n    return [str, ''];\n  }\n  return [str.slice(0, colonAt), str.slice(colonAt + 1)];\n};\n\nexport function tokenizedValueFromString(\n  str: string,\n  providers: SuggestionProvider[],\n): TokenizingFieldValue {\n  const [token, value] = tokenizeString(str);\n  if (findProviderByToken(token, providers)) {\n    if (token && value) {\n      return {token, value};\n    }\n  }\n\n  return {value: str};\n}\n\nexport const tokenToString = (v: TokenizingFieldValue) =>\n  v.token ? `${v.token}:${v.value}` : v.value;\n\nexport const tokensAsStringArray = (value: TokenizingFieldValue[]) =>\n  value.filter((v) => v.value !== '').map(tokenToString);\n\nexport const stringFromValue = (value: TokenizingFieldValue[]) =>\n  tokensAsStringArray(value).join(',');\n\nconst isEqual = (a: TokenizingFieldValue, b?: TokenizingFieldValue) =>\n  b && a.token === b.token && a.value === b.value;\n\n/** Provides a text field with typeahead autocompletion.\n *  This completion either provides a list of standalone tokens\n *  sourced from the `tokens` param, or a set of key value pairs,\n *  sourced from the `suggestionProviders` param. In the latter case, the\n *  key is one of a known set of \"suggestion provider tokens\".\n *\n *  Provide one or more SuggestionProviders or a list of tokens\n *  to build the tree of autocompletions.\n *\n *  The input also allows for freeform typing (`value` items with no token value) */\nexport const TokenizingField: React.FC<TokenizingFieldProps> = ({\n  suggestionProviders,\n  suggestionProvidersFilter,\n  values: externalValues,\n  maxValues,\n  onChange,\n  onChangeBeforeCommit,\n  onFocus,\n  onTextChange,\n  placeholder,\n  addOnBlur,\n  loading,\n  className,\n  fullwidth,\n  suggestionRenderer,\n}) => {\n  const [open, setOpen] = React.useState<boolean>(false);\n  const [active, setActive] = React.useState<ActiveSuggestionInfo | null>(null);\n  const [typed, setTyped] = React.useState<string>('');\n\n  const values = React.useMemo(() => [...externalValues], [externalValues]);\n  const typedValue = tokenizedValueFromString(typed, suggestionProviders);\n  if (isEqual(typedValue, values[values.length - 1])) {\n    values.pop();\n  }\n\n  const atMaxValues = maxValues !== undefined && values.length >= maxValues;\n\n  const filteredSuggestionProviders = suggestionProvidersFilter\n    ? suggestionProvidersFilter(suggestionProviders, values)\n    : suggestionProviders;\n\n  // Build the set of suggestions that should be displayed for the current input value.\n  // Note: \"typed\" is the text that has not yet been submitted, separate from values[].\n  const parts = typed.split(':');\n  const lastPart = (parts[parts.length - 1] || '').toLowerCase();\n\n  const suggestions = React.useMemo(() => {\n    if (atMaxValues) {\n      return [];\n    }\n\n    let suggestionsArr: Suggestion[] = [];\n\n    const matchesTypedText = (query: string, s: Suggestion) =>\n      !query ||\n      s.text\n        .toLowerCase()\n        .split(':')\n        .some((c) => c.includes(query));\n\n    const availableSuggestionsForProvider = (provider: SuggestionProvider) => {\n      const suggestionNotUsed = (v: string) =>\n        !values.some((e) => e.token === provider.token && e.value === v);\n\n      const suggestionFilter = provider.suggestionFilter || matchesTypedText;\n\n      return provider\n        .values()\n        .filter(suggestionNotUsed)\n        .map((v) => ({\n          text: provider?.token ? `${provider.token}:${v}` : v,\n          final: !provider.textOnly,\n        }))\n        .filter((s) => suggestionFilter(lastPart, s))\n        .slice(0, MAX_SUGGESTIONS); // never show too many suggestions for one provider\n    };\n\n    if (parts.length === 1) {\n      // Suggest providers (eg: `pipeline:`) so users can discover the search space\n\n      suggestionsArr = filteredSuggestionProviders\n        .reduce(\n          (accum: Suggestion[], s) =>\n            s.token ? [...accum, {text: `${s.token}:`, final: false}] : accum,\n          [],\n        )\n        .filter((s) => matchesTypedText(lastPart, s));\n\n      // Suggest value completions so users can type \"airline_\" without the \"pipeline\"\n      // prefix and get the correct suggestion.\n      for (const p of filteredSuggestionProviders) {\n        if (!p.token || typed.length > 0) {\n          suggestionsArr.push(...availableSuggestionsForProvider(p));\n        }\n      }\n    }\n\n    if (parts.length === 2) {\n      const firstPart = parts[0];\n      if (firstPart) {\n        // Suggest values from the chosen provider (eg: `pipeline:abc`)\n        const provider = findProviderByToken(firstPart, filteredSuggestionProviders);\n        suggestionsArr = provider ? availableSuggestionsForProvider(provider) : [];\n      }\n    }\n\n    // Truncate suggestions to the ones currently matching the typed text,\n    // and always sort them in alphabetical order.\n    suggestionsArr.sort((a, b) => a.text.localeCompare(b.text));\n\n    return suggestionsArr;\n  }, [atMaxValues, filteredSuggestionProviders, lastPart, parts, typed.length, values]);\n\n  const _onTextChange = (text: string) => {\n    setTyped(text);\n    onTextChange && onTextChange(text);\n  };\n\n  // We need to manage selection in the dropdown by ourselves. To ensure the\n  // best behavior we store the active item's index and text (the text allows\n  // us to relocate it if it's moved and the index allows us to keep selection\n  // at the same location if the previous item is gone.)\n\n  // This hook keeps the active row state in sync with the suggestions, which\n  // are derived from the current input value.\n\n  React.useEffect(() => {\n    // If suggestions are present, autoselect the first one so the user can press\n    // enter to complete their search. (Esc + enter is how you enter your raw text.)\n    if (!active && suggestions.length) {\n      const item = suggestions[0];\n      if (item) {\n        setActive({text: item.text, idx: 0});\n      }\n      return;\n    }\n    if (!active) {\n      return;\n    }\n    if (suggestions.length === 0) {\n      setActive(null);\n      return;\n    }\n\n    // Relocate the currently active item in the latest suggestions list\n    const pos = suggestions.findIndex((a) => a.text === active.text);\n\n    // The new index is the index of the active item, or whatever item\n    // is now at it's location if it's gone, bounded to the array.\n    let nextIdx = pos !== -1 ? pos : active.idx;\n    nextIdx = Math.max(0, Math.min(suggestions.length - 1, nextIdx));\n    const nextItem = suggestions[nextIdx];\n\n    if (nextItem && (nextIdx !== active.idx || nextItem.text !== active.text)) {\n      setActive({text: nextItem.text, idx: nextIdx});\n    }\n  }, [active, suggestions]);\n\n  const onConfirmSuggestion = (suggestion: Suggestion) => {\n    if (atMaxValues) {\n      return;\n    }\n\n    if (suggestion.final) {\n      // The user has finished a key-value pair\n      onConfirmText(suggestion.text);\n      _onTextChange('');\n      setActive(null);\n      setOpen(false);\n    } else {\n      // The user has finished a key\n      _onTextChange(suggestion.text);\n    }\n  };\n\n  const onConfirmText = (str: string) => {\n    if (atMaxValues) {\n      return;\n    }\n    if (str.endsWith(':')) {\n      return;\n    }\n    if (str === '') {\n      return;\n    }\n\n    _onTextChange('');\n    onChange([...values, tokenizedValueFromString(str, filteredSuggestionProviders)]);\n  };\n\n  const onKeyDown = (e: React.KeyboardEvent<any>) => {\n    if (atMaxValues && e.key !== 'Delete' && e.key !== 'Backspace') {\n      e.preventDefault();\n      e.stopPropagation();\n      return;\n    }\n    // Enter and Return confirm the currently selected suggestion or\n    // confirm the freeform text you've typed if no suggestions are shown.\n    if (e.key === 'Enter' || e.key === 'Return' || e.key === 'Tab') {\n      if (active) {\n        const picked = suggestions.find((s) => s.text === active.text);\n        if (!picked) {\n          throw new Error('Selection out of sync with suggestions');\n        }\n        onConfirmSuggestion(picked);\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (typed.length) {\n        onConfirmText(typed);\n        e.preventDefault();\n        e.stopPropagation();\n      }\n      return;\n    }\n\n    // Typing space confirms your freeform text\n    if (e.key === ' ') {\n      e.preventDefault();\n      onConfirmText(typed);\n      return;\n    }\n\n    // Escape closes the options. The options re-open if you type another char or click.\n    if (e.key === 'Escape') {\n      setActive(null);\n      setOpen(false);\n      return;\n    }\n\n    if (!open && e.key !== 'Delete' && e.key !== 'Backspace') {\n      setOpen(true);\n    }\n\n    // The up/down arrow keys shift selection in the dropdown.\n    // Note: The first down arrow press activates the first item.\n    const shift = {ArrowDown: 1, ArrowUp: -1}[e.key];\n    if (shift && suggestions.length > 0) {\n      e.preventDefault();\n      let idx = (active ? active.idx : -1) + shift;\n      idx = Math.max(0, Math.min(idx, suggestions.length - 1));\n      const item = suggestions[idx];\n      if (item) {\n        setActive({text: item.text, idx});\n      }\n    }\n  };\n\n  const menuRef = React.createRef<HTMLDivElement>();\n  React.useEffect(() => {\n    if (menuRef.current && active) {\n      const el = menuRef.current.querySelector(`[data-idx='${active.idx}']`);\n      if (el && el instanceof HTMLElement && 'scrollIntoView' in el) {\n        el.scrollIntoView({block: 'nearest'});\n      }\n    }\n  }, [menuRef, active]);\n\n  const renderSuggestion = suggestionRenderer || ((suggestion) => suggestion.text);\n\n  return (\n    <Popover\n      isOpen={open && suggestions.length > 0 && !atMaxValues}\n      position=\"bottom-left\"\n      content={\n        suggestions.length > 0 ? (\n          <div style={{maxHeight: 235, overflowY: 'scroll'}} ref={menuRef}>\n            <StyledMenu>\n              {suggestions.map((suggestion, idx) => (\n                <MenuItem\n                  data-idx={idx}\n                  key={suggestion.text}\n                  text={renderSuggestion(suggestion)}\n                  shouldDismissPopover={false}\n                  active={active?.idx === idx}\n                  onMouseDown={(e: React.MouseEvent<any>) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    onConfirmSuggestion(suggestion);\n                    setActive(null);\n                  }}\n                />\n              ))}\n            </StyledMenu>\n          </div>\n        ) : (\n          <div />\n        )\n      }\n    >\n      <StyledTagInput\n        className={className}\n        values={values.map((v) => (v.token ? `${v.token}:${v.value}` : v.value))}\n        inputValue={typed}\n        onRemove={(_, idx) => {\n          const next = [...values];\n          next.splice(idx, 1);\n          onChange(next);\n        }}\n        onInputChange={(e) => {\n          _onTextChange(e.currentTarget.value);\n\n          if (onChangeBeforeCommit) {\n            const tokenized = tokenizedValueFromString(\n              e.currentTarget.value,\n              filteredSuggestionProviders,\n            );\n            onChange([...values, tokenized]);\n          }\n        }}\n        inputProps={{\n          onFocus: () => {\n            setOpen(true);\n            onFocus && onFocus();\n          },\n          onBlur: () => {\n            // Emulate behavior of addOnBlur for TagInput\n            // When a user clicks outside of the input, finish the current token\n            if (addOnBlur) {\n              onConfirmText(typed);\n            }\n            setOpen(false);\n          },\n        }}\n        $maxWidth={fullwidth ? '100%' : undefined}\n        onAdd={() => false}\n        onKeyDown={onKeyDown}\n        tagProps={{minimal: true}}\n        placeholder={placeholder || 'Filter…'}\n        rightElement={\n          loading && open ? (\n            <Box style={{alignSelf: 'center'}} margin={{right: 4}}>\n              <Spinner purpose=\"body-text\" />\n            </Box>\n          ) : undefined\n        }\n      />\n    </Popover>\n  );\n};\n\nexport const StyledTagInput = styled(TagInput)<{$maxWidth?: any}>`\n  border: none;\n  border-radius: 8px;\n  box-shadow: ${Colors.Gray300} inset 0px 0px 0px 1px, ${Colors.KeylineGray} inset 2px 2px 1.5px;\n  min-width: 400px;\n  max-width: ${(p) => (p.$maxWidth ? p.$maxWidth : '600px')};\n  transition: box-shadow 150ms;\n\n  &.bp4-active {\n    box-shadow: ${Colors.Gray300} inset 0px 0px 0px 1px, ${Colors.KeylineGray} inset 2px 2px 1.5px,\n      rgba(58, 151, 212, 0.6) 0 0 0 3px;\n  }\n\n  input {\n    font-size: 14px;\n    font-weight: 400;\n    padding-left: 4px;\n    padding-bottom: 2px;\n    padding-top: 2px;\n  }\n\n  && .bp4-tag-input-values:first-child .bp4-input-ghost:first-child {\n    padding-left: 8px;\n  }\n\n  && .bp4-tag-input-values {\n    margin-right: 4px;\n    margin-top: 4px;\n  }\n\n  && .bp4-tag-input-values > * {\n    margin-bottom: 4px;\n  }\n\n  .bp4-tag {\n    border-radius: 6px;\n    display: inline-flex;\n    flex-direction: row;\n    font-size: 12px;\n    line-height: 16px;\n    align-items: center;\n    max-width: 400px;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    padding: 4px 8px;\n    user-select: none;\n  }\n\n  .bp4-tag.bp4-minimal:not([class*='bp4-intent-']) {\n    background-color: ${Colors.Gray100};\n    color: ${Colors.Gray900};\n  }\n\n  .bp4-tag.bp4-minimal.bp4-intent-success {\n    background-color: ${Colors.Green50};\n    color: ${Colors.Green700};\n  }\n\n  .bp4-tag.bp4-minimal.bp4-intent-warning {\n    background-color: ${Colors.Yellow50};\n    color: ${Colors.Yellow700};\n  }\n\n  .bp4-tag.bp4-minimal.bp4-intent-danger {\n    background-color: ${Colors.Red50};\n    color: ${Colors.Red700};\n  }\n`;\n\nconst StyledMenu = styled(Menu)`\n  width: 400px;\n`;\n"],"names":["currentQueryString","useQueryPersistedState","options","queryKey","defaults","encode","decode","raw","qs","inferTypeOfQueryParam","location","useLocation","history","useHistory","qsDecoded","React","search","ignoreQueryPrefix","qsWithDefaults","result","Object","keys","key","inferTypeOfQueryParams","valueRef","onChangeRef","updated","next","entries","value","replace","pathname","arrayFormat","isEqual","current","q","PipelineReference","pipelineName","pipelineHrefContext","isJob","snapshotId","showIcon","truncationThreshold","size","truncatedName","length","slice","pipeline","to","workspacePipelinePathGuessRepo","workspacePipelinePath","repoName","name","repoLocation","flex","direction","alignItems","display","margin","right","color","Colors","queuedStatuses","Set","RunStatus","inProgressStatuses","successStatuses","failedStatuses","doneStatuses","cancelableStatuses","RUN_PROVIDERS_EMPTY","token","values","useQueryPersistedRunFilters","enabledFilters","tokens","tokensAsStringArray","cursor","undefined","tokenizedValuesFromStringArray","filter","t","includes","runsPathWithFilters","filterTokens","runsFilterForSearchTokens","obj","item","runIds","push","statuses","split","tags","RunsFilterInput","loading","onChange","useRepositoryOptions","selectedTagKey","setSelectedTagKey","useLazyQuery","RUN_TAG_KEYS_QUERY","fetchTagKeys","tagKeyData","data","RUN_TAG_VALUES_QUERY","variables","tagKeys","fetchTagValues","tagValueData","suggestions","repositoryOptions","runTagKeys","selectedRunTagKey","runTagValues","pipelineNames","jobNames","repository","pipelines","add","Array","from","map","flat","textOnly","x","searchSuggestionsForRuns","runTagKeysOrError","__typename","runTagsOrError","onFocus","onTextChange","text","startsWith","tagKeyText","suggestionProviders","suggestionProvidersFilter","limitedTokens","presentLimitedTokens","has","provider","gql","NonIdealState","title","description","icon","action","shrinkable","singleContentElement","Boolean","gap","background","padding","style","borderRadius","width","maxWidth","purpose","findProviderByToken","providers","find","p","toLowerCase","tokenizedValuesFromString","str","tokenizedValueFromString","colonAt","indexOf","tokenizeString","tokenToString","v","stringFromValue","join","TokenizingField","a","b","externalValues","maxValues","onChangeBeforeCommit","placeholder","addOnBlur","className","fullwidth","suggestionRenderer","open","setOpen","active","setActive","typed","setTyped","typedValue","pop","atMaxValues","filteredSuggestionProviders","parts","lastPart","suggestionsArr","matchesTypedText","query","s","some","c","availableSuggestionsForProvider","suggestionFilter","e","final","reduce","accum","firstPart","sort","localeCompare","_onTextChange","pos","findIndex","nextIdx","idx","Math","max","min","nextItem","onConfirmSuggestion","suggestion","onConfirmText","endsWith","menuRef","el","querySelector","HTMLElement","scrollIntoView","block","renderSuggestion","isOpen","position","content","maxHeight","overflowY","ref","StyledMenu","shouldDismissPopover","onMouseDown","preventDefault","stopPropagation","StyledTagInput","inputValue","onRemove","_","splice","onInputChange","currentTarget","tokenized","inputProps","onBlur","$maxWidth","onAdd","onKeyDown","shift","ArrowDown","ArrowUp","picked","Error","tagProps","minimal","rightElement","alignSelf","styled","TagInput","Menu"],"sourceRoot":""}