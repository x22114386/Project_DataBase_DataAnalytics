{"version":3,"file":"static/js/523.6f51e425.chunk.js","mappings":"ieAmCMA,EACI,IAKJC,EAAoB,UAEbC,EAAmB,SAACC,GAC/B,IAAMC,EAAI,IAAIC,EAAAA,SAAAA,MAAqB,CAACC,UAAU,IAE9CF,EAAEG,SAAS,CACTC,QAAS,KACTC,QAAST,EACTU,QAASV,EACTW,QAAS,GACTC,QAAS,GACTC,QAAS,KAEXT,EAAEU,qBAAoB,iBAAO,MAE7B,IAb0E,EAapEC,EAAsB,SAACC,GAAD,MAC1B,CACEf,EACAe,EAAKC,WAAWC,WAAWC,SAASC,KACpCJ,EAAKC,WAAWC,WAAWE,KAC3BJ,EAAKC,WAAWI,WAChBC,KAAK,OAGHC,EAAe,SAACP,GAAD,OAAsBA,GACrCQ,EAAgBC,OAAOC,OAAOvB,EAAUwB,OAAOC,OAAOL,GAEtDM,EAAsC,GAzB8B,UA0BvDL,GA1BuD,IA0B1E,2BAAkC,CAAC,IAAxBR,EAAuB,QAChC,GAAIA,EAAKC,WAAWI,UAAW,CAC7B,IAAMS,EAAKf,EAAoBC,GAC/Ba,EAAOC,GAAM,CACXA,GAAAA,EACAT,UAAWL,EAAKC,WAAWI,UAC3BU,eAAgBf,EAAKC,WAAWC,WAAWE,KAC3CY,uBAAwBhB,EAAKC,WAAWC,WAAWC,SAASC,KAC5Da,kCAAkC,EAClCC,OAAQ,CAACC,EAAG,EAAGC,EAAG,EAAGC,MAAO,EAAGC,OAAQ,MAnC6B,8BAyC1E,IAAMC,EAAad,OAAOe,KAAKX,GAAQY,OAAS,EAC5CF,GACFd,OAAOe,KAAKX,GAAQa,SAAQ,SAACC,GAAD,OAAavC,EAAEwC,QAAQD,EAAS,OAI9DnB,EAAckB,SAAQ,SAAC1B,GACrBZ,EAAEwC,QAAQ5B,EAAKc,GAAIe,EAAuB7B,EAAKC,aAC3CsB,GAAcvB,EAAKC,WAAWI,WAChCjB,EAAE0C,UAAU9B,EAAKc,GAAIf,EAAoBC,OAI7C,IAAM+B,EAAuD,GAI7DtB,OAAOe,KAAKrC,EAAU6C,YAAYN,SAAQ,SAACO,GACnBxB,OAAOe,KAAKrC,EAAU6C,WAAWC,IACzCP,SAAQ,SAACQ,IAEL/C,EAAUwB,MAAMuB,IAChB/C,EAAUwB,MAAMsB,MAKhC7C,EAAE+C,QAAQ,CAACC,EAAGH,EAAYI,EAAGH,GAAe,CAACI,OAAQ,IAEnCnD,EAAUwB,MAAMuB,GAET/C,EAAUwB,MAAMsB,KACtCF,EAAuCE,IAAc,GAFrDF,EAAuCG,IAAgB,SAQ9DzB,OAAOe,KAAKO,GAAgCL,SAAQ,SAACZ,GACnD1B,EAAEwC,QAAQd,EAAIyB,QAGhBlD,EAAAA,OAAaD,GAEb,IAAIoD,EAAW,EACXC,EAAY,EAEV9B,EAAqC,GAsB3C,GApBAvB,EAAEuB,QAAQe,SAAQ,SAACZ,GACjB,IAAM4B,EAAYtD,EAAEY,KAAKc,GACzB,GAAK4B,EAAL,CAGA,IAAMxB,EAAS,CACbC,EAAGuB,EAAUvB,EAAIuB,EAAUrB,MAAQ,EACnCD,EAAGsB,EAAUtB,EAAIsB,EAAUpB,OAAS,EACpCD,MAAOqB,EAAUrB,MACjBC,OAAQoB,EAAUpB,QAEfR,EAAG6B,WAAW1D,KACjB0B,EAAMG,GAAM,CAACA,GAAAA,EAAII,OAAAA,IAGnBsB,EAAWI,KAAKC,IAAIL,EAAUE,EAAUvB,EAAIuB,EAAUrB,MAAQ,GAC9DoB,EAAYG,KAAKC,IAAIJ,EAAWC,EAAUtB,EAAIsB,EAAUpB,OAAS,OAI/DC,EAAY,CAAC,IAAD,YACKf,GADL,IACd,2BAAkC,CAAC,IAAxBR,EAAuB,QAChC,GAAIA,EAAKC,WAAWI,UAAW,CAC7B,IAAMsB,EAAU5B,EAAoBC,GACpCa,EAAOc,GAAST,OACmB,IAAjCL,EAAOc,GAAST,OAAOG,MACnBV,EAAMX,EAAKc,IAAII,OACf4B,EAAajC,EAAOc,GAAST,OAAQP,EAAMX,EAAKc,IAAII,UAPhD,8BAUd,cAAoBT,OAAOC,OAAOG,GAAlC,eAA2C,CAAtC,IAAMkC,EAAK,KACdA,EAAM7B,OAAS8B,EAAUD,EAAM7B,OAAQ,CAACC,EAAG,GAAI8B,IAAK,GAAIC,QAAS,MAKrEzC,OAAOC,OAAOyC,GAAAA,CAAQ1C,OAAOC,OAAOG,IAAS,SAACzB,GAAD,OAAOA,EAAEiB,cACnDO,QAAO,SAACwC,GAAD,OAASA,EAAI3B,OAAS,KAC7B4B,OACA3B,SAAQ,SAACqB,GACRA,EAAM7B,OAAOE,GAAK,GAClB2B,EAAM7B,OAAOI,QAAU,GACvByB,EAAM9B,kCAAmC,KAG7C,IAAMqC,EAA2B,GAiBjC,OAfAlE,EAAEkE,QAAQ5B,SAAQ,SAAC6B,GACjB,IAAMnB,EAAIhD,EAAEY,KAAKuD,EAAEnB,GACboB,EAAYzB,EAA+BwB,EAAEnB,GAAK,GAAK,GACvDC,EAAIjD,EAAEY,KAAKuD,EAAElB,GACboB,EAAY1B,EAA+BwB,EAAElB,GAAK,GAAK,GAG7DiB,EAAMI,KAAK,CACTC,KAAM,CAACxC,EAAGiB,EAAEjB,EAAIiB,EAAEf,MAAQ,EAAImC,EAASpC,EAAGgB,EAAEhB,EAAI,GAAKgB,EAAEd,OAAS,GAChEsC,OAAQL,EAAEnB,EACVyB,GAAI,CAAC1C,EAAGkB,EAAElB,EAAIkB,EAAEhB,MAAQ,EAAIoC,EAASrC,EAAGiB,EAAEjB,EAAI,GAAKiB,EAAEf,OAAS,GAC9DwC,KAAMP,EAAElB,OAIL,CACL1B,MAAAA,EACA2C,MAAAA,EACAjC,MAAOmB,EAAWxD,EAClBsC,OAAQmB,EAAYzD,EACpB6B,OAAQU,EAAaV,EAAS,KAIrBkD,EAA6B,GAE7BxB,EAAyB,WACpC,MAAO,CAAClB,MAAO,IAAKC,OAAQ,KAGjB0B,EAAY,SAACgB,EAAYC,GACpC,MAAO,CACL9C,EAAG6C,EAAE7C,EAAI8C,EAAQ9C,EACjBC,EAAG4C,EAAE5C,EAAI6C,EAAQhB,IACjB5B,MAAO2C,EAAE3C,MAAoB,EAAZ4C,EAAQ9C,EACzBG,OAAQ0C,EAAE1C,OAAS2C,EAAQhB,IAAMgB,EAAQf,SAIhCJ,EAAe,SAACkB,EAAYE,GACvC,IAAMC,EAAOvB,KAAKwB,IAAIJ,EAAE7C,EAAG+C,EAAE/C,GACvBkD,EAAOzB,KAAKwB,IAAIJ,EAAE5C,EAAG8C,EAAE9C,GAG7B,MAAO,CAACD,EAAGgD,EAAM/C,EAAGiD,EAAMhD,MAFbuB,KAAKC,IAAImB,EAAE7C,EAAI6C,EAAE3C,MAAO6C,EAAE/C,EAAI+C,EAAE7C,OAEL8C,EAAM7C,OADjCsB,KAAKC,IAAImB,EAAE5C,EAAI4C,EAAE1C,OAAQ4C,EAAE9C,EAAI8C,EAAE5C,QACe+C,IAGlDC,EAA6B,GAE7BzC,EAAyB,SAAC0C,GAYrC,GAAIA,EAAIC,WAAaD,EAAIE,aACvB,MAAO,CAACpD,MAHI,IAGGC,OAAQ,KAEvB,IAAIA,EAAS,IAab,OAXIiD,EAAIG,gBACNpD,GAAU,IAERiD,EAAIC,SACNlD,GAAU,GAEVA,GAAU,GAKL,CAACD,MAlBI,IAkBGC,OAFfA,GAAU,M,kBC1OdqD,EAAOC,QAXP,SAAyBC,EAAOC,EAAQC,EAAUC,GAIhD,IAHA,IAAIC,GAAS,EACTxD,EAAkB,MAAToD,EAAgB,EAAIA,EAAMpD,SAE9BwD,EAAQxD,GAAQ,CACvB,IAAIyD,EAAQL,EAAMI,GAClBH,EAAOE,EAAaE,EAAOH,EAASG,GAAQL,GAE9C,OAAOG,I,oBClBT,IAAIG,EAAWC,EAAQ,OAoBvBT,EAAOC,QAPP,SAAwBS,EAAYP,EAAQC,EAAUC,GAIpD,OAHAG,EAASE,GAAY,SAASH,EAAOI,EAAKD,GACxCP,EAAOE,EAAaE,EAAOH,EAASG,GAAQG,MAEvCL,I,sBCjBT,IAAIO,EAAkBH,EAAQ,OAC1BI,EAAiBJ,EAAQ,KACzBK,EAAeL,EAAQ,OACvBM,EAAUN,EAAQ,OAmBtBT,EAAOC,QATP,SAA0BE,EAAQa,GAChC,OAAO,SAASN,EAAYN,GAC1B,IAAIa,EAAOF,EAAQL,GAAcE,EAAkBC,EAC/CR,EAAcW,EAAcA,IAAgB,GAEhD,OAAOC,EAAKP,EAAYP,EAAQW,EAAaV,EAAU,GAAIC,M,sBClB/D,IAAIa,EAAkBT,EAAQ,OAC1BU,EAAmBV,EAAQ,OAM3BW,EAHctF,OAAOuF,UAGQD,eAyB7B5C,EAAU2C,GAAiB,SAASG,EAAQf,EAAOI,GACjDS,EAAeG,KAAKD,EAAQX,GAC9BW,EAAOX,GAAK5B,KAAKwB,GAEjBW,EAAgBI,EAAQX,EAAK,CAACJ,OAIlCP,EAAOC,QAAUzB,G,iFCvCF,SAASgD,EAA2BC,EAAGC,GACpD,IAAIC,EAAuB,qBAAXC,QAA0BH,EAAEG,OAAOC,WAAaJ,EAAE,cAElE,IAAKE,EAAI,CACP,GAAIG,MAAMf,QAAQU,KAAOE,GAAK,OAA2BF,KAAOC,GAAkBD,GAAyB,kBAAbA,EAAE3E,OAAqB,CAC/G6E,IAAIF,EAAIE,GACZ,IAAII,EAAI,EAEJC,EAAI,aAER,MAAO,CACLC,EAAGD,EACHE,EAAG,WACD,OAAIH,GAAKN,EAAE3E,OAAe,CACxBqF,MAAM,GAED,CACLA,MAAM,EACN5B,MAAOkB,EAAEM,OAGbnD,EAAG,SAAWwD,GACZ,MAAMA,GAERC,EAAGL,GAIP,MAAM,IAAIM,UAAU,yIAGtB,IAEIC,EAFAC,GAAmB,EACnBC,GAAS,EAEb,MAAO,CACLR,EAAG,WACDN,EAAKA,EAAGJ,KAAKE,IAEfS,EAAG,WACD,IAAIQ,EAAOf,EAAGgB,OAEd,OADAH,EAAmBE,EAAKP,KACjBO,GAET9D,EAAG,SAAWgE,GACZH,GAAS,EACTF,EAAMK,GAERP,EAAG,WACD,IACOG,GAAoC,MAAhBb,EAAW,QAAWA,EAAW,SAC1D,QACA,GAAIc,EAAQ,MAAMF","sources":["../../core/src/asset-graph/layout.ts","../../../node_modules/lodash/_arrayAggregator.js","../../../node_modules/lodash/_baseAggregator.js","../../../node_modules/lodash/_createAggregator.js","../../../node_modules/lodash/groupBy.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["import * as dagre from 'dagre';\nimport groupBy from 'lodash/groupBy';\n\nimport {IBounds, IPoint} from '../graph/common';\n\nimport {GraphData, GraphNode, GraphId} from './Utils';\n\nexport interface AssetLayout {\n  id: GraphId;\n  bounds: IBounds; // Overall frame of the box relative to 0,0 on the graph\n}\n\nexport interface GroupLayout {\n  id: GraphId;\n  groupName: string;\n  repositoryName: string;\n  repositoryLocationName: string;\n  repositoryDisambiguationRequired: boolean;\n  bounds: IBounds; // Overall frame of the box relative to 0,0 on the graph\n}\nexport type AssetLayoutEdge = {\n  from: IPoint;\n  fromId: string;\n  to: IPoint;\n  toId: string;\n};\n\nexport type AssetGraphLayout = {\n  width: number;\n  height: number;\n  edges: AssetLayoutEdge[];\n  nodes: {[id: string]: AssetLayout};\n  groups: {[name: string]: GroupLayout};\n};\n\nconst opts: {margin: number} = {\n  margin: 100,\n};\n\n// Prefix group nodes in the Dagre layout so that an asset and an asset\n// group cannot have the same name.\nconst GROUP_NODE_PREFIX = 'group__';\n\nexport const layoutAssetGraph = (graphData: GraphData): AssetGraphLayout => {\n  const g = new dagre.graphlib.Graph({compound: true});\n\n  g.setGraph({\n    rankdir: 'TB',\n    marginx: opts.margin,\n    marginy: opts.margin,\n    nodesep: 40,\n    edgesep: 10,\n    ranksep: 10,\n  });\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const parentNodeIdForNode = (node: GraphNode) =>\n    [\n      GROUP_NODE_PREFIX,\n      node.definition.repository.location.name,\n      node.definition.repository.name,\n      node.definition.groupName,\n    ].join('__');\n\n  // const shouldRender = (node?: GraphNode) => node && node.definition.opNames.length > 0;\n  const shouldRender = (node?: GraphNode) => node;\n  const renderedNodes = Object.values(graphData.nodes).filter(shouldRender);\n\n  const groups: {[id: string]: GroupLayout} = {};\n  for (const node of renderedNodes) {\n    if (node.definition.groupName) {\n      const id = parentNodeIdForNode(node);\n      groups[id] = {\n        id,\n        groupName: node.definition.groupName,\n        repositoryName: node.definition.repository.name,\n        repositoryLocationName: node.definition.repository.location.name,\n        repositoryDisambiguationRequired: false,\n        bounds: {x: 0, y: 0, width: 0, height: 0},\n      };\n    }\n  }\n\n  // Add all the group boxes to the graph\n  const showGroups = Object.keys(groups).length > 1;\n  if (showGroups) {\n    Object.keys(groups).forEach((groupId) => g.setNode(groupId, {}));\n  }\n\n  // Add all the nodes to the graph\n  renderedNodes.forEach((node) => {\n    g.setNode(node.id, getAssetNodeDimensions(node.definition));\n    if (showGroups && node.definition.groupName) {\n      g.setParent(node.id, parentNodeIdForNode(node));\n    }\n  });\n\n  const linksToAssetsOutsideGraphedSet: {[id: string]: true} = {};\n\n  // Add the edges to the graph, and accumulate a set of \"foreign nodes\" (for which\n  // we have an inbound/outbound edge, but we don't have the `node` in the graphData).\n  Object.keys(graphData.downstream).forEach((upstreamId) => {\n    const downstreamIds = Object.keys(graphData.downstream[upstreamId]);\n    downstreamIds.forEach((downstreamId) => {\n      if (\n        !shouldRender(graphData.nodes[downstreamId]) &&\n        !shouldRender(graphData.nodes[upstreamId])\n      ) {\n        return;\n      }\n\n      g.setEdge({v: upstreamId, w: downstreamId}, {weight: 1});\n\n      if (!shouldRender(graphData.nodes[downstreamId])) {\n        (linksToAssetsOutsideGraphedSet as any)[downstreamId] = true;\n      } else if (!shouldRender(graphData.nodes[upstreamId])) {\n        (linksToAssetsOutsideGraphedSet as any)[upstreamId] = true;\n      }\n    });\n  });\n\n  // Add all the link nodes to the graph\n  Object.keys(linksToAssetsOutsideGraphedSet).forEach((id) => {\n    g.setNode(id, getAssetLinkDimensions());\n  });\n\n  dagre.layout(g);\n\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  const nodes: {[id: string]: AssetLayout} = {};\n\n  g.nodes().forEach((id) => {\n    const dagreNode = g.node(id);\n    if (!dagreNode) {\n      return;\n    }\n    const bounds = {\n      x: dagreNode.x - dagreNode.width / 2,\n      y: dagreNode.y - dagreNode.height / 2,\n      width: dagreNode.width,\n      height: dagreNode.height,\n    };\n    if (!id.startsWith(GROUP_NODE_PREFIX)) {\n      nodes[id] = {id, bounds};\n    }\n\n    maxWidth = Math.max(maxWidth, dagreNode.x + dagreNode.width / 2);\n    maxHeight = Math.max(maxHeight, dagreNode.y + dagreNode.height / 2);\n  });\n\n  // Apply bounds to the groups based on the nodes inside them\n  if (showGroups) {\n    for (const node of renderedNodes) {\n      if (node.definition.groupName) {\n        const groupId = parentNodeIdForNode(node);\n        groups[groupId].bounds =\n          groups[groupId].bounds.width === 0\n            ? nodes[node.id].bounds\n            : extendBounds(groups[groupId].bounds, nodes[node.id].bounds);\n      }\n    }\n    for (const group of Object.values(groups)) {\n      group.bounds = padBounds(group.bounds, {x: 15, top: 70, bottom: -10});\n    }\n  }\n\n  // Annotate groups that require disambiguation (same group name appears twice)\n  Object.values(groupBy(Object.values(groups), (g) => g.groupName))\n    .filter((set) => set.length > 1)\n    .flat()\n    .forEach((group) => {\n      group.bounds.y -= 18;\n      group.bounds.height += 18;\n      group.repositoryDisambiguationRequired = true;\n    });\n\n  const edges: AssetLayoutEdge[] = [];\n\n  g.edges().forEach((e) => {\n    const v = g.node(e.v);\n    const vXInset = !!linksToAssetsOutsideGraphedSet[e.v] ? 16 : 24;\n    const w = g.node(e.w);\n    const wXInset = !!linksToAssetsOutsideGraphedSet[e.w] ? 16 : 24;\n\n    // Ignore the coordinates from dagre and use the top left + bottom left of the\n    edges.push({\n      from: {x: v.x - v.width / 2 + vXInset, y: v.y - 30 + v.height / 2},\n      fromId: e.v,\n      to: {x: w.x - w.width / 2 + wXInset, y: w.y + 20 - w.height / 2},\n      toId: e.w,\n    });\n  });\n\n  return {\n    nodes,\n    edges,\n    width: maxWidth + opts.margin,\n    height: maxHeight + opts.margin,\n    groups: showGroups ? groups : {},\n  };\n};\n\nexport const ASSET_LINK_NAME_MAX_LENGTH = 10;\n\nexport const getAssetLinkDimensions = () => {\n  return {width: 106, height: 90};\n};\n\nexport const padBounds = (a: IBounds, padding: {x: number; top: number; bottom: number}) => {\n  return {\n    x: a.x - padding.x,\n    y: a.y - padding.top,\n    width: a.width + padding.x * 2,\n    height: a.height + padding.top + padding.bottom,\n  };\n};\n\nexport const extendBounds = (a: IBounds, b: IBounds) => {\n  const xmin = Math.min(a.x, b.x);\n  const ymin = Math.min(a.y, b.y);\n  const xmax = Math.max(a.x + a.width, b.x + b.width);\n  const ymax = Math.max(a.y + a.height, b.y + b.height);\n  return {x: xmin, y: ymin, width: xmax - xmin, height: ymax - ymin};\n};\n\nexport const ASSET_NODE_NAME_MAX_LENGTH = 28;\n\nexport const getAssetNodeDimensions = (def: {\n  assetKey: {path: string[]};\n  opNames: string[];\n  isSource: boolean;\n  isObservable: boolean;\n  isPartitioned: boolean;\n  graphName: string | null;\n  description?: string | null;\n  computeKind: string | null;\n}) => {\n  const width = 265;\n\n  if (def.isSource && !def.isObservable) {\n    return {width, height: 102};\n  } else {\n    let height = 100; // top tags area + name + description\n\n    if (def.isPartitioned) {\n      height += 40;\n    }\n    if (def.isSource) {\n      height += 30; // observed\n    } else {\n      height += 26; // status row\n    }\n\n    height += 30; // tag\n\n    return {width, height};\n  }\n};\n","/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayAggregator;\n","var baseEach = require('./_baseEach');\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseAggregator;\n","var arrayAggregator = require('./_arrayAggregator'),\n    baseAggregator = require('./_baseAggregator'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nmodule.exports = createAggregator;\n","var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nmodule.exports = groupBy;\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["opts","GROUP_NODE_PREFIX","layoutAssetGraph","graphData","g","dagre","compound","setGraph","rankdir","marginx","marginy","nodesep","edgesep","ranksep","setDefaultEdgeLabel","parentNodeIdForNode","node","definition","repository","location","name","groupName","join","shouldRender","renderedNodes","Object","values","nodes","filter","groups","id","repositoryName","repositoryLocationName","repositoryDisambiguationRequired","bounds","x","y","width","height","showGroups","keys","length","forEach","groupId","setNode","getAssetNodeDimensions","setParent","linksToAssetsOutsideGraphedSet","downstream","upstreamId","downstreamId","setEdge","v","w","weight","getAssetLinkDimensions","maxWidth","maxHeight","dagreNode","startsWith","Math","max","extendBounds","group","padBounds","top","bottom","groupBy","set","flat","edges","e","vXInset","wXInset","push","from","fromId","to","toId","ASSET_LINK_NAME_MAX_LENGTH","a","padding","b","xmin","min","ymin","ASSET_NODE_NAME_MAX_LENGTH","def","isSource","isObservable","isPartitioned","module","exports","array","setter","iteratee","accumulator","index","value","baseEach","require","collection","key","arrayAggregator","baseAggregator","baseIteratee","isArray","initializer","func","baseAssignValue","createAggregator","hasOwnProperty","prototype","result","call","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","i","F","s","n","done","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2"],"sourceRoot":""}